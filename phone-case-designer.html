<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Edge â€” Custom Phone Case Designer</title>
  <meta name="description" content="Edge is the premium phone case design studio for crafting custom daily carry art with AI and precision controls." />
  <meta property="og:title" content="Edge â€” Custom Phone Case Designer" />
  <meta property="og:description" content="Edge is the premium phone case studio built for sharp ideas, AI generation, and precise print-ready control." />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://edge.design/phone-case-designer" />
  <meta property="og:site_name" content="Edge" />
  <meta name="twitter:card" content="summary_large_image" />
  <meta name="twitter:title" content="Edge â€” Custom Phone Case Designer" />
  <meta name="twitter:description" content="Edge is the premium phone case studio built for sharp ideas, AI generation, and precise print-ready control." />
  <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Product",
      "name": "Edge Phone Case Designer",
      "brand": {
        "@type": "Brand",
        "name": "Edge"
      },
      "description": "Edge is the premium phone case studio for crafting custom cases with AI-assisted design tools.",
      "url": "https://edge.design/phone-case-designer"
    }
  </script>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700;800&display=swap">
  <style>
    :root {
      color-scheme: dark;
      --brand-name: "Edge";
      --bg: #050507;
      --bg-accent: radial-gradient(circle at 18% 22%, rgba(255, 77, 31, 0.16), transparent 55%);
      --bg-accent-2: radial-gradient(circle at 82% 0%, rgba(98, 111, 255, 0.12), transparent 64%);
      --surface: rgba(12, 14, 22, 0.82);
      --surface-solid: #0f111a;
      --surface-soft: rgba(18, 21, 31, 0.72);
      --stroke: rgba(255, 255, 255, 0.08);
      --stroke-soft: rgba(255, 255, 255, 0.04);
      --text-primary: #f4f5ff;
      --text-secondary: #9da3bc;
      --text-tertiary: rgba(244, 245, 255, 0.62);
      --accent: #ff4d1f;
      --accent-strong: #ff6b2c;
      --accent-glow: rgba(255, 77, 31, 0.32);
      --accent-low: rgba(255, 77, 31, 0.14);
      --radius-xl: 36px;
      --radius-lg: 28px;
      --radius-md: 18px;
      --radius-sm: 12px;
      font-size: 16px;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: "Plus Jakarta Sans", "Inter", "Segoe UI", sans-serif;
      background: var(--bg);
      background-image: var(--bg-accent), var(--bg-accent-2), linear-gradient(180deg, #050507 0%, #090912 55%, #040507 100%);
      color: var(--text-primary);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
      letter-spacing: -0.01em;
    }
    img {
      max-width: 100%;
      display: block;
    }
    header {
      position: sticky;
      top: 0;
      z-index: 20;
      background: rgba(5, 6, 9, 0.82);
      border-bottom: 1px solid var(--stroke);
      backdrop-filter: blur(24px);
    }
    main {
      margin: 0;
    }
    .container {
      max-width: 1180px;
      margin: 0 auto;
      padding: 0 clamp(1.5rem, 4vw, 4rem);
    }
    .site-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 2rem;
      min-height: 72px;
    }
    .branding {
      display: inline-flex;
      align-items: center;
      text-decoration: none;
      color: inherit;
    }
    .brand-lockup,
    .footer-lockup {
      display: inline-flex;
      align-items: center;
      gap: 0.7rem;
      padding: 0.5rem 1rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(140deg, rgba(15, 18, 27, 0.9), rgba(28, 34, 48, 0.6));
      position: relative;
      overflow: hidden;
      box-shadow: 0 18px 38px rgba(7, 9, 15, 0.6);
      transition: transform 200ms ease, box-shadow 200ms ease;
    }
    .brand-lockup::before,
    .footer-lockup::before {
      content: "";
      position: absolute;
      inset: -45% -35% auto -35%;
      height: 140%;
      background: radial-gradient(circle at top, rgba(255, 118, 63, 0.55), transparent 65%);
      opacity: 0.45;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .branding:hover .brand-lockup,
    .branding:focus-visible .brand-lockup {
      transform: translateY(-2px);
      box-shadow: 0 24px 52px rgba(7, 9, 15, 0.72);
    }
    .brand-emblem {
      display: grid;
      place-items: center;
      width: 56px;
      height: 56px;
      border-radius: 18px;
      background: radial-gradient(circle at 30% 28%, rgba(255, 255, 255, 0.18), transparent 68%), #0b0f17;
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: inset 0 0 12px rgba(255, 255, 255, 0.04), 0 16px 28px rgba(5, 7, 12, 0.55);
      position: relative;
      z-index: 1;
      flex-shrink: 0;
    }
    .brand-icon {
      width: 46px;
      height: auto;
      filter: drop-shadow(0 12px 18px rgba(5, 7, 12, 0.65));
    }
    .brand-wordmark {
      font-size: 1.05rem;
      letter-spacing: 0.32em;
      font-weight: 700;
      text-transform: uppercase;
      color: #f5f7ff;
      position: relative;
      z-index: 1;
      text-shadow: 0 4px 12px rgba(0, 0, 0, 0.45);
    }
    nav {
      display: flex;
      align-items: center;
      gap: clamp(1rem, 3vw, 1.8rem);
    }
    nav a {
      text-decoration: none;
      font-weight: 500;
      color: var(--text-secondary);
      font-size: 0.95rem;
      position: relative;
      padding-bottom: 0.25rem;
      transition: color 200ms ease;
    }
    nav a::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(135deg, rgba(255, 77, 31, 0.8), rgba(255, 118, 63, 0.4));
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 200ms ease;
    }
    nav a:hover,
    nav a:focus-visible {
      color: var(--text-primary);
    }
    nav a:hover::after,
    nav a:focus-visible::after {
      transform: scaleX(1);
    }
    .primary-cta {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      background: linear-gradient(135deg, #ff591f, #ff7a38);
      color: #0b0d13;
      border-radius: 999px;
      padding: 0.8rem 1.8rem;
      font-weight: 700;
      font-size: 0.96rem;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 26px 50px var(--accent-glow);
      transition: transform 180ms ease, box-shadow 180ms ease, filter 200ms ease;
    }
    .primary-cta:hover,
    .primary-cta:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 32px 70px rgba(255, 77, 31, 0.4);
      filter: brightness(1.05);
    }
    .page {
      display: flex;
      flex-direction: column;
      gap: clamp(3.2rem, 6vw, 6rem);
      padding-bottom: clamp(3rem, 8vw, 6rem);
    }
    .layout-grid {
      display: grid;
      gap: clamp(2.4rem, 5vw, 4rem);
      grid-template-columns: minmax(0, 1fr);
      align-items: flex-start;
    }
    .workspace-column {
      display: flex;
      flex-direction: column;
      gap: clamp(2.5rem, 5vw, 3.5rem);
    }
    .hero-intro {
      padding-top: clamp(4rem, 9vw, 6.5rem);
    }
    .hero-eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.22em;
      font-size: 0.78rem;
      color: var(--accent);
      font-weight: 700;
      margin-bottom: 1rem;
    }
    .hero-intro h1 {
      margin: 0 0 1.6rem;
      font-size: clamp(3rem, 5vw, 4.4rem);
      line-height: 1.04;
      letter-spacing: -0.03em;
    }
    .hero-intro p {
      margin: 0 0 2rem;
      color: var(--text-secondary);
      max-width: 44ch;
      font-size: 1.05rem;
    }
    .hero-intro .cta-push {
      margin: 0 0 1rem;
      display: inline-flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.65rem 1.1rem;
      border-radius: var(--radius-sm);
      border: 1px solid rgba(255, 77, 31, 0.32);
      background: rgba(255, 77, 31, 0.12);
      color: var(--accent-strong);
      font-size: 0.95rem;
      font-weight: 700;
      letter-spacing: -0.005em;
      box-shadow: 0 20px 40px rgba(255, 77, 31, 0.16);
    }
    .hero-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 1.15rem;
      align-items: center;
    }
    .secondary-link {
      color: var(--text-primary);
      text-decoration: none;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 0.45rem;
      padding: 0.35rem 0;
      border-bottom: 1px solid transparent;
      transition: color 180ms ease, border-color 180ms ease;
    }
    .secondary-link:hover,
    .secondary-link:focus-visible {
      color: var(--accent-strong);
      border-color: rgba(255, 77, 31, 0.45);
    }
    .preview-stack {
      display: flex;
      flex-direction: column;
      gap: 1.8rem;
    }
    .preview-rail {
      display: flex;
      flex-direction: column;
      gap: 1.8rem;
    }
    .preview-card {
      background: linear-gradient(160deg, rgba(255, 77, 31, 0.12), rgba(9, 11, 19, 0.88));
      border-radius: var(--radius-lg);
      padding: clamp(1.9rem, 3vw, 2.5rem);
      border: 1px solid var(--stroke);
      box-shadow: 0 38px 80px rgba(8, 10, 18, 0.55);
    }
    .preview-card.dark {
      background: radial-gradient(circle at top, rgba(255, 77, 31, 0.2), transparent 65%), #0d0f17;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }
    .preview-card h3 {
      margin: 0 0 0.75rem;
      font-size: 1.22rem;
    }
    .preview-card p {
      margin: 0 0 1.6rem;
      color: var(--text-secondary);
    }
    .canvas-wrapper {
      position: relative;
      width: min(420px, 92vw);
      margin: 0;
      min-height: 840px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: min-height 300ms ease;
    }
    .canvas-wrapper img#phoneImage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100%;
      height: auto;
      max-height: 100%;
      z-index: 1;
      pointer-events: none;
      filter: drop-shadow(0 20px 40px rgba(0, 0, 0, 0.4));
      opacity: 1;
      mix-blend-mode: normal;
      object-fit: contain;
      transition: opacity 200ms ease;
    }
    canvas {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 30px;
      background: transparent;
      box-shadow: none;
      position: relative;
      z-index: 2;
    }
    #phoneImage {
      display: block !important;
    }
    .canvas-overlay {
      position: absolute;
      inset: 0;
      border-radius: 30px;
      pointer-events: none;
      border: 2px solid rgba(255, 77, 31, 0.42);
      opacity: 0;
      transition: opacity 250ms ease, border-color 250ms ease;
    }
    .canvas-wrapper.dragging .canvas-overlay,
    .canvas-wrapper.preview-mask .canvas-overlay {
      opacity: 1;
    }
    .canvas-wrapper.preview-mask .canvas-overlay {
      border-color: rgba(255, 118, 63, 0.65);
      box-shadow: 0 0 0 2px rgba(255, 77, 31, 0.28);
    }
    .live-info {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.78rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-tertiary);
      margin-bottom: 1rem;
      gap: 1rem;
      flex-wrap: wrap;
    }
    .live-info select {
      background: var(--surface-soft);
      border: 1px solid var(--stroke);
      color: var(--text-primary);
      border-radius: var(--radius-sm);
      padding: 0.5rem 0.75rem;
      font-size: 0.85rem;
      font-family: inherit;
      cursor: pointer;
      transition: border-color 180ms ease, background 180ms ease;
    }
    .live-info select option {
      background: var(--surface-solid);
      color: var(--text-primary);
      padding: 0.5rem;
    }
    .live-info select:hover,
    .live-info select:focus {
      border-color: rgba(255, 118, 63, 0.45);
      background: rgba(255, 255, 255, 0.08);
      outline: none;
    }
    .section,
    .workspace-section {
      display: flex;
      flex-direction: column;
      gap: 1.6rem;
    }
    .section-heading {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1.1rem;
    }
    .section-heading h2 {
      margin: 0;
      font-size: clamp(2.2rem, 3vw, 2.8rem);
      letter-spacing: -0.02em;
    }
    .section-heading p {
      margin: 0;
      color: var(--text-secondary);
      max-width: 44ch;
    }
    .card {
      background: linear-gradient(180deg, rgba(14, 16, 24, 0.92), rgba(9, 10, 16, 0.9));
      border-radius: var(--radius-lg);
      padding: clamp(1.9rem, 3vw, 2.5rem);
      border: 1px solid var(--stroke);
      box-shadow: 0 34px 70px rgba(6, 8, 14, 0.55);
      display: flex;
      flex-direction: column;
      gap: 1.35rem;
    }
    .card h3 {
      margin: 0;
      font-size: 1.42rem;
    }
    .card-subtitle {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.98rem;
    }
    .card-grid {
      display: grid;
      gap: clamp(1.6rem, 4vw, 2.4rem);
    }
    .card-grid.two {
      grid-template-columns: minmax(0, 1fr);
    }
    .card-grid.three {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }
    label {
      font-size: 0.82rem;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-tertiary);
    }
    textarea,
    input[type="text"],
    input[type="file"] {
      width: 100%;
      border-radius: var(--radius-sm);
      border: 1px solid var(--stroke-soft);
      padding: 0.95rem 1.1rem;
      font-size: 1rem;
      background: rgba(255, 255, 255, 0.02);
      color: var(--text-primary);
      transition: border-color 180ms ease, box-shadow 180ms ease, background 180ms ease;
      font-family: inherit;
      resize: vertical;
    }
    textarea::placeholder,
    input::placeholder {
      color: rgba(244, 245, 255, 0.35);
    }
    textarea:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: rgba(255, 118, 63, 0.65);
      box-shadow: 0 0 0 3px var(--accent-low);
      background: rgba(255, 255, 255, 0.05);
    }
    textarea {
      min-height: 140px;
    }
    .quick-prompts {
      display: flex;
      flex-wrap: wrap;
      gap: 0.85rem;
    }
    button {
      cursor: pointer;
      border: none;
      border-radius: 999px;
      font-size: 0.95rem;
      font-weight: 600;
      padding: 0.75rem 1.45rem;
      transition: transform 160ms ease, box-shadow 160ms ease, background 160ms ease, color 160ms ease, border-color 160ms ease;
      font-family: inherit;
    }
    .btn-accent,
    .btn-ghost {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
    }
    .btn-accent {
      background: linear-gradient(135deg, #ff5a22, #ff8342);
      color: #0a0c12;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 20px 44px var(--accent-glow);
    }
    .btn-accent:hover:not(:disabled),
    .btn-accent:focus-visible:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 26px 60px rgba(255, 77, 31, 0.42);
    }
    .btn-ghost {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-primary);
      border: 1px solid var(--stroke);
    }
    .btn-ghost:hover,
    .btn-ghost:focus-visible {
      background: rgba(255, 255, 255, 0.08);
      border-color: rgba(255, 255, 255, 0.18);
      color: var(--accent-strong);
    }
    .quick-prompts button {
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-secondary);
      border: 1px solid rgba(255, 255, 255, 0.06);
      font-weight: 600;
      letter-spacing: 0.02em;
    }
    .quick-prompts button:hover,
    .quick-prompts button:focus-visible {
      color: var(--accent-strong);
      border-color: rgba(255, 118, 63, 0.3);
      background: rgba(255, 118, 63, 0.12);
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
      filter: grayscale(0.3);
    }
    button:disabled:hover {
      transform: none !important;
    }
    .drop-zone {
      border-radius: var(--radius-lg);
      border: 1px dashed rgba(255, 255, 255, 0.18);
      padding: clamp(2.25rem, 3vw, 3rem);
      text-align: center;
      background: linear-gradient(135deg, rgba(255, 77, 31, 0.14), transparent 65%);
      transition: border-color 160ms ease, background 160ms ease, color 160ms ease;
      color: var(--text-secondary);
      font-weight: 600;
    }
    .drop-zone.dragover {
      border-color: rgba(255, 118, 63, 0.75);
      background: linear-gradient(135deg, rgba(255, 77, 31, 0.22), transparent 70%);
      color: var(--text-primary);
    }
    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 1.1rem;
    }
    .control {
      background: rgba(255, 255, 255, 0.04);
      border-radius: var(--radius-md);
      padding: 1.35rem;
      border: 1px solid var(--stroke-soft);
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--text-primary);
      text-transform: none;
      letter-spacing: 0.02em;
      display: grid;
      gap: 0.7rem;
      transition: border-color 160ms ease, background 160ms ease, box-shadow 160ms ease;
    }
    .control:hover,
    .control:focus-within {
      border-color: rgba(255, 118, 63, 0.45);
      background: rgba(255, 255, 255, 0.07);
      box-shadow: 0 18px 40px rgba(8, 10, 18, 0.45);
    }
    .control input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    #dragHint {
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-secondary);
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 0.75rem;
      font-weight: 600;
      color: var(--text-primary);
      cursor: pointer;
    }
    .toggle input {
      width: 52px;
      height: 28px;
      -webkit-appearance: none;
      appearance: none;
      background: rgba(255, 255, 255, 0.14);
      border-radius: 999px;
      position: relative;
      transition: background 160ms ease;
      border: 1px solid rgba(255, 255, 255, 0.16);
    }
    .toggle input::after {
      content: "";
      position: absolute;
      inset: 4px;
      border-radius: 50%;
      background: #0a0c12;
      box-shadow: 0 6px 12px rgba(10, 12, 18, 0.45);
      transition: transform 160ms ease, background 160ms ease;
    }
    .toggle input:checked {
      background: linear-gradient(135deg, #ff5a22, #ff7f3f);
      border-color: rgba(255, 255, 255, 0.22);
    }
    .toggle input:checked::after {
      transform: translateX(22px);
      background: #ffffff;
    }
    .status {
      min-height: 1.5rem;
      font-size: 0.9rem;
      color: var(--text-secondary);
      padding: 0.5rem 0;
      transition: color 200ms ease;
    }
    .status.error {
      color: #ff6159;
      font-weight: 600;
    }
    .status.success {
      color: #4ade80;
      font-weight: 600;
    }
    .status.warning {
      color: #fbbf24;
      font-weight: 600;
    }
    .ai-card-header {
      display: flex;
      flex-direction: column;
      gap: 0.6rem;
    }
    .ai-card-lede {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
    .ai-step {
      display: grid;
      gap: 0.8rem;
      padding: 1.15rem 1.35rem;
      border-radius: var(--radius-sm);
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--stroke-soft);
    }
    .ai-step.optional {
      background: rgba(255, 255, 255, 0.02);
    }
    .ai-step-label {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.6rem 1.2rem;
      border-radius: 999px;
      background: linear-gradient(135deg, rgba(255, 77, 31, 0.24), rgba(255, 118, 63, 0.32));
      border: 1px solid rgba(255, 118, 63, 0.48);
      box-shadow: 0 18px 36px rgba(255, 77, 31, 0.22);
      color: var(--text-primary);
      font-family: "Plus Jakarta Sans", "Inter", "Segoe UI", sans-serif;
      font-size: clamp(0.9rem, 0.6vw + 0.88rem, 1.08rem);
      font-weight: 770;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }
    .ai-step-icon {
      font-size: 1.3rem;
      line-height: 1;
    }
    .ai-step-text {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      line-height: 1.2;
    }
    .ai-helper {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.92rem;
    }
    .prompt-input-group {
      display: grid;
      gap: 0.75rem;
    }
    .quick-prompts.example-prompts {
      justify-content: flex-start;
    }
    .quick-prompts.example-prompts button {
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      border-color: rgba(255, 255, 255, 0.16);
    }
    .quick-prompts.example-prompts button:hover,
    .quick-prompts.example-prompts button:focus-visible {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 118, 63, 0.4);
    }
    .vibe-carousel {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 1rem;
    }
    .vibe-card {
      display: grid;
      gap: 1rem;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid var(--stroke);
      border-radius: var(--radius-md);
      padding: clamp(1.2rem, 3vw, 1.6rem);
    }
    .vibe-case {
      width: clamp(120px, 30vw, 160px);
      height: clamp(240px, 60vw, 300px);
      border-radius: 28px;
      background: linear-gradient(160deg, rgba(255, 255, 255, 0.12), rgba(12, 16, 28, 0.12));
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.18), 0 18px 38px rgba(5, 8, 14, 0.55);
      position: relative;
      overflow: hidden;
      display: grid;
      place-items: center;
      color: rgba(255, 255, 255, 0.88);
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      font-size: 0.82rem;
    }
    .vibe-case::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 28px;
      border: 2px solid rgba(255, 255, 255, 0.18);
      pointer-events: none;
    }
    .vibe-case-label {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.35);
      backdrop-filter: blur(6px);
    }
    .vibe-meta {
      display: grid;
      gap: 0.55rem;
    }
    .vibe-name {
      margin: 0;
      font-size: 1.12rem;
      font-weight: 600;
    }
    .vibe-description {
      margin: 0;
      color: var(--text-secondary);
      font-size: 0.95rem;
    }
    .vibe-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.45rem;
    }
    .vibe-tag {
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      font-size: 0.82rem;
      letter-spacing: 0.02em;
      color: var(--text-secondary);
      background: rgba(255, 255, 255, 0.05);
    }
    .vibe-nav {
      width: 42px;
      height: 42px;
      border-radius: 50%;
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.04);
      color: var(--text-primary);
      display: grid;
      place-items: center;
      font-size: 1.1rem;
    }
    .vibe-nav:hover,
    .vibe-nav:focus-visible {
      border-color: rgba(255, 118, 63, 0.45);
      color: var(--accent-strong);
    }
    .vibe-nav:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }
    .vibe-dots {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      justify-content: center;
    }
    .vibe-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.08);
      padding: 0;
    }
    .vibe-dot.active {
      border-color: rgba(255, 118, 63, 0.8);
      background: rgba(255, 118, 63, 0.6);
    }
    .finish-grid {
      display: grid;
      gap: 1.1rem;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .layout-options {
      border: none;
      padding: 0;
      margin: 0;
      display: grid;
      gap: 0.75rem;
    }
    .layout-options legend {
      font-size: 0.86rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      margin-bottom: 0.65rem;
      color: var(--text-tertiary);
    }
    .layout-option {
      display: grid;
      gap: 0.25rem;
      padding: 0.65rem 0.75rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--stroke-soft);
      background: rgba(255, 255, 255, 0.02);
      grid-template-columns: auto 1fr;
      align-items: start;
      column-gap: 0.6rem;
    }
    .layout-option label {
      font-size: 0.96rem;
      letter-spacing: 0.02em;
      font-weight: 600;
      text-transform: none;
      color: var(--text-primary);
      grid-column: 2;
      display: grid;
      gap: 0.2rem;
    }
    .layout-option-title {
      font-weight: 600;
    }
    .layout-option-description {
      font-size: 0.85rem;
      color: var(--text-secondary);
      letter-spacing: 0.01em;
    }
    .layout-option input[type="radio"] {
      width: 18px;
      height: 18px;
      margin: 0.2rem 0 0 0;
      grid-column: 1;
    }
    .finish-column {
      display: grid;
      gap: 0.55rem;
    }
    .finish-column label {
      font-size: 0.86rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-tertiary);
    }
    .finish-column input {
      background: rgba(255, 255, 255, 0.03);
      color: var(--text-primary);
    }
    .reference-block {
      display: grid;
      gap: 0.6rem;
      margin-top: 1.2rem;
    }
    .reference-block label {
      font-size: 0.86rem;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-tertiary);
    }
    .overlay-upload {
      display: grid;
      gap: 0.45rem;
    }
    .overlay-file-input {
      width: 100%;
      padding: 0.7rem 0.85rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.03);
      color: var(--text-secondary);
      cursor: pointer;
    }
    .overlay-file-input::file-selector-button {
      margin-right: 0.9rem;
      padding: 0.45rem 1rem;
      border-radius: var(--radius-sm);
      border: 1px solid var(--stroke);
      background: rgba(255, 255, 255, 0.08);
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
    }
    .overlay-file-input::file-selector-button:hover,
    .overlay-file-input::file-selector-button:focus-visible {
      background: rgba(255, 255, 255, 0.12);
    }
    .overlay-remove-btn {
      justify-self: start;
      padding: 0.32rem 0.95rem;
      font-size: 0.75rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: transparent;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      color: var(--text-tertiary);
      cursor: pointer;
      transition: border 180ms ease, color 180ms ease, background 180ms ease;
    }
    .overlay-remove-btn:hover,
    .overlay-remove-btn:focus-visible {
      color: var(--text-primary);
      border-color: rgba(255, 255, 255, 0.28);
      background: rgba(255, 255, 255, 0.05);
    }
    .overlay-preview {
      border: 1px dashed rgba(255, 255, 255, 0.14);
      border-radius: var(--radius-sm);
      min-height: 132px;
      display: grid;
      place-items: center;
      text-align: center;
      padding: 1rem;
      background: rgba(255, 255, 255, 0.02);
      color: var(--text-secondary);
      font-size: 0.85rem;
    }
    .overlay-preview img {
      max-width: 100%;
      max-height: 100%;
      border-radius: calc(var(--radius-sm) - 4px);
      display: block;
      box-shadow: 0 10px 24px rgba(5, 7, 12, 0.35);
    }
    .ai-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.9rem;
      align-items: center;
    }
    .ai-actions .ai-helper {
      font-size: 0.82rem;
      color: var(--text-tertiary);
    }
    .surprise-action {
      justify-self: start;
      width: fit-content;
    }
    .actions {
      display: flex;
      flex-wrap: wrap;
      gap: 1.15rem;
      align-items: center;
    }
    .final-card {
      background: radial-gradient(circle at 100% 0%, rgba(255, 77, 31, 0.24), transparent 58%), linear-gradient(180deg, rgba(11, 13, 19, 0.92), rgba(7, 8, 13, 0.92));
      color: var(--text-primary);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: var(--radius-lg);
      padding: clamp(2rem, 3vw, 2.7rem);
      box-shadow: 0 44px 92px rgba(5, 7, 12, 0.65);
      display: grid;
      gap: 1.35rem;
    }
    .final-card-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
    }
    .final-card h3 {
      margin: 0;
      font-size: 1.62rem;
    }
    .final-card p {
      margin: 0;
      color: var(--text-tertiary);
    }
    .final-card-badge {
      padding: 0.5rem 1.1rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 118, 63, 0.45);
      background: rgba(255, 77, 31, 0.16);
      color: var(--accent-strong);
      font-size: 0.78rem;
      font-weight: 700;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      white-space: nowrap;
    }
    .final-card-actions {
      display: grid;
      gap: 1.4rem;
    }
    .final-card-tools {
      display: flex;
      flex-wrap: wrap;
      gap: 0.9rem;
    }
    .btn-tool {
      flex: 1 1 180px;
      min-width: 160px;
    }
    .final-card-tools .btn-ghost {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.28);
      color: var(--text-primary);
    }
    .final-card-tools .btn-ghost:hover,
    .final-card-tools .btn-ghost:focus-visible {
      color: var(--accent-strong);
      border-color: rgba(255, 118, 63, 0.6);
      background: rgba(255, 118, 63, 0.12);
    }
    .final-card-tools .btn-accent {
      flex: 1 1 220px;
      min-width: 200px;
    }
    .order-callout {
      display: grid;
      gap: 0.85rem;
      text-align: center;
      padding: clamp(1.4rem, 3vw, 1.9rem);
      border-radius: var(--radius-md);
      background: linear-gradient(155deg, rgba(255, 77, 31, 0.28), rgba(11, 13, 19, 0.88));
      border: 1px solid rgba(255, 137, 82, 0.4);
      box-shadow: 0 34px 70px rgba(255, 77, 31, 0.28);
    }
    .order-push {
      margin: 0;
      color: var(--text-primary);
      font-size: 1.02rem;
      font-weight: 700;
      letter-spacing: -0.01em;
    }
    .btn-order {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 1.05rem clamp(1.6rem, 4vw, 2.6rem);
      border-radius: 999px;
      background: linear-gradient(135deg, #ff6a24, #ff8a3a 55%, #ffb56f);
      color: #07090f;
      font-size: 1.02rem;
      font-weight: 800;
      text-decoration: none;
      border: 1px solid rgba(255, 210, 181, 0.68);
      box-shadow: 0 32px 70px rgba(255, 99, 46, 0.45);
      transition: transform 180ms ease, box-shadow 180ms ease, filter 200ms ease;
    }
    .btn-order:hover,
    .btn-order:focus-visible {
      transform: translateY(-2px);
      box-shadow: 0 40px 90px rgba(255, 118, 63, 0.55);
      filter: brightness(1.06);
    }
    .order-note {
      margin: 0;
      color: rgba(244, 245, 255, 0.72);
      font-size: 0.85rem;
      letter-spacing: 0.02em;
    }
    .final-card .status {
      color: var(--text-secondary);
    }
    #preview3d {
      width: 100%;
      aspect-ratio: 1;
      border-radius: var(--radius-md);
      background: linear-gradient(160deg, rgba(14, 15, 24, 0.92), rgba(8, 9, 15, 0.8));
      display: grid;
      place-items: center;
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: var(--text-tertiary);
      text-align: center;
      padding: 1.2rem;
    }
    footer {
      padding: clamp(2.8rem, 5vw, 4.4rem) 0 clamp(3.6rem, 7vw, 5rem);
      background: radial-gradient(circle at top, rgba(255, 77, 31, 0.12), transparent 52%), #030406;
      color: rgba(244, 245, 255, 0.72);
      font-size: 0.95rem;
      letter-spacing: 0.02em;
    }
    .footer-band {
      display: flex;
      flex-direction: column;
      gap: clamp(1.8rem, 3vw, 2.6rem);
      align-items: center;
      justify-content: center;
      text-align: center;
      max-width: 1100px;
      margin: 0 auto;
      padding: 0 clamp(1.5rem, 4vw, 3rem);
    }
    .footer-brand {
      display: grid;
      gap: 1.4rem;
      justify-items: center;
    }
    .footer-lockup {
      padding: 0.65rem 1.45rem;
      background: linear-gradient(145deg, rgba(12, 15, 22, 0.92), rgba(35, 43, 61, 0.65));
      border-color: rgba(255, 255, 255, 0.18);
    }
    .footer-lockup::before {
      background: radial-gradient(circle at top, rgba(98, 111, 255, 0.4), transparent 68%);
      opacity: 0.5;
    }
    .footer-copy {
      max-width: 520px;
      display: grid;
      gap: 0.6rem;
    }
    .footer-title {
      margin: 0;
      font-size: 1.12rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: #f7f8ff;
    }
    .footer-tagline {
      margin: 0;
      color: var(--text-tertiary);
      font-size: 0.98rem;
      letter-spacing: 0.04em;
    }
    .footer-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.85rem;
      justify-content: center;
    }
    .footer-actions .btn-ghost {
      border-color: rgba(255, 255, 255, 0.24);
      color: var(--text-primary);
      background: rgba(255, 255, 255, 0.04);
    }
    .footer-actions .btn-ghost:hover,
    .footer-actions .btn-ghost:focus-visible {
      border-color: rgba(255, 118, 63, 0.5);
      color: var(--accent-strong);
      background: rgba(255, 118, 63, 0.14);
    }
    .footer-note {
      margin: clamp(2.2rem, 4vw, 3rem) auto 0;
      max-width: 680px;
      text-align: center;
      color: rgba(244, 245, 255, 0.45);
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 0.82rem;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }
    .loading {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }
    .spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255, 118, 63, 0.2);
      border-top-color: var(--accent);
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    @media (min-width: 1100px) {
      .layout-grid {
        grid-template-columns: minmax(0, 1fr) minmax(320px, 420px);
      }
      .preview-rail {
        position: sticky;
        top: clamp(6rem, 9vw, 6.5rem);
        align-self: flex-start;
      }
      .canvas-wrapper {
        margin: 0 auto;
      }
    }
    @media (max-width: 1100px) {
      nav {
        display: none;
      }
      .site-header {
        justify-content: space-between;
      }
      .layout-grid {
        grid-template-columns: minmax(0, 1fr);
      }
      .preview-rail {
        position: static;
      }
      .canvas-wrapper {
        margin: 0 auto;
      }
    }
    @media (max-width: 768px) {
      .card-grid.two,
      .card-grid.three {
        grid-template-columns: minmax(0, 1fr);
      }
      .hero-intro h1 {
        font-size: clamp(2.6rem, 8vw, 3.3rem);
      }
      .hero-intro p {
        font-size: 1rem;
      }
    }
    @media (max-width: 600px) {
      .primary-cta {
        width: 100%;
        justify-content: center;
      }
      .actions {
        width: 100%;
      }
      .actions .btn-accent,
      .actions .btn-ghost {
        flex: 1 1 auto;
        justify-content: center;
      }
      .final-card-header {
        flex-direction: column;
        align-items: flex-start;
        gap: 0.8rem;
      }
      .final-card-badge {
        align-self: stretch;
        text-align: center;
      }
      .order-callout {
        padding: 1.2rem;
      }
    }
  </style>
</head>
<body data-brand="Edge">
  <header>
    <div class="container site-header">
      <a class="branding" href="#" aria-label="Edge home">
        <span class="brand-lockup" aria-hidden="true">
          <span class="brand-emblem">
            <svg class="brand-icon" viewBox="0 0 120 70" role="presentation" focusable="false">
              <defs>
                <linearGradient id="brand-peak-base" x1="8%" y1="86%" x2="74%" y2="12%" gradientUnits="userSpaceOnUse">
                  <stop offset="0%" stop-color="#0a0d16" />
                  <stop offset="52%" stop-color="#1f2639" />
                  <stop offset="100%" stop-color="#39486a" />
                </linearGradient>
                <linearGradient id="brand-peak-glow" x1="18%" y1="84%" x2="82%" y2="8%" gradientUnits="userSpaceOnUse">
                  <stop offset="0%" stop-color="#ffffff" stop-opacity="0.85" />
                  <stop offset="55%" stop-color="#ffffff" stop-opacity="0.45" />
                  <stop offset="100%" stop-color="#f2f4ff" stop-opacity="0" />
                </linearGradient>
              </defs>
              <path d="M7 58L36 22l14 20 10-12 23 24 15-12 17 30H7Z" fill="url(#brand-peak-base)" />
              <path d="M36 22l14 20 10-12 7 8 11-9 8 27-19-18-9 7-12-16-10-7Z" fill="url(#brand-peak-glow)" />
              <path d="M7 58L36 22l14 20 10-12 23 24 15-12 17 30" fill="none" stroke="rgba(255,255,255,0.65)" stroke-width="2" stroke-linejoin="round" />
            </svg>
          </span>
          <span class="brand-wordmark">EDGE</span>
        </span>
        <span class="sr-only">Edge â€” Custom Phone Case Designer</span>
      </a>
      <nav aria-label="Primary">
        <a href="#ai">AI Studio</a>
        <a href="#upload">Uploads</a>
        <a href="#controls">Controls</a>
      </nav>
    </div>
  </header>
  <main class="page">
    <div class="container layout-grid">
      <div class="workspace-column">
        <section class="workspace-section hero-intro" aria-labelledby="hero-title">
          <p class="hero-eyebrow">Phone Case Studio</p>
          <h1 id="hero-title">Edge turns bold ideas into daily carry art.</h1>
          <p>Edge is the premium phone case studio built for sharp ideas, AI-powered generation, and meticulous, print-ready control.</p>
          <p class="cta-push">Design yours today for Â£19.99â€”free case and free delivery included!</p>
          <div class="hero-actions">
            <a class="primary-cta" href="#ai">Lock In My Â£19.99 Custom Case Now</a>
            <a class="secondary-link" href="#upload">Upload your design -></a>
          </div>
        </section>

        <section class="workspace-section" aria-labelledby="ai-section-title">
          <div class="section-heading">
            <h2 id="ai-section-title">Craft with AI or upload instantly</h2>
            <p>Kickstart a new concept with Gemini or import your finished artwork. Everything lives in one studio.</p>
          </div>
          <div class="card-grid two">
            <article class="card" id="ai" aria-labelledby="ai-title">
              <div class="ai-card-header">
                <div>
                  <h3 id="ai-title">AI Designer</h3>
                  <p class="card-subtitle">Describe your dream case and watch it come to life.</p>
                  <p class="ai-card-lede">Type anything you like, from "Y2K glitter with my name in bold" to "sunset over Tokyo skyline with sakura petals." Then customize with styles, moods, and flips until it is perfect.</p>
                </div>
              </div>

              <section class="ai-step" aria-labelledby="ai-step-1">
                <div class="ai-step-label" id="ai-step-1">
                  <span class="ai-step-icon" aria-hidden="true">ðŸŸ¦</span>
                  <span class="ai-step-text">STEP 1 â€” DESCRIBE YOUR CASE</span>
                </div>
                <p class="ai-helper">Type anything you would love on your case - characters, colors, patterns, or text. This part is powered by AI image generation plus optional overlays.</p>
                <div class="prompt-input-group">
                  <label class="sr-only" for="promptInput">Describe your dream case</label>
                  <textarea id="promptInput" placeholder="Type anything you'd love on your case... like 'purple moon and stars with my name'"></textarea>
                </div>
                <p class="ai-helper">Need ideas? Tap one of these:</p>
                <div class="quick-prompts example-prompts" role="group" aria-label="Prompt examples">
                  <button class="btn-ghost" type="button" data-prompt="Dark ocean waves with glowing jellyfish and neon text">Dark ocean waves with glowing jellyfish and neon text</button>
                  <button class="btn-ghost" type="button" data-prompt="Cute pink mushrooms and tiny frogs">Cute pink mushrooms and tiny frogs</button>
                  <button class="btn-ghost" type="button" data-prompt="My dog flying through space with rainbow trails">My dog flying through space with rainbow trails</button>
                </div>
                <div class="reference-block">
                  <label for="promptReferenceUpload">Use a reference photo (optional)</label>
                  <div class="overlay-upload">
                    <input id="promptReferenceUpload" class="overlay-file-input" type="file" accept="image/png,image/jpeg,image/webp" />
                    <button id="promptReferenceClear" class="overlay-remove-btn" type="button">Remove reference</button>
                    <div id="promptReferencePreview" class="overlay-preview" aria-live="polite">No reference image added yet.</div>
                  </div>
                  <p class="ai-helper">We will feed this image into Gemini so it keeps your subject while following the prompt.</p>
                </div>
              </section>

              <section class="ai-step" aria-labelledby="ai-step-2">
                <div class="ai-step-label" id="ai-step-2">
                  <span class="ai-step-icon" aria-hidden="true">ðŸŸ¥</span>
                  <span class="ai-step-text">STEP 2 â€” FINISH & ADD CUSTOM DETAILS</span>
                </div>
                <p class="ai-helper">Want to add your name? Or a small icon? You can!</p>
                <div class="finish-grid">
                  <fieldset class="layout-options">
                    <legend>Layout</legend>
                    <div class="layout-option">
                      <input type="radio" name="layoutOption" value="center" id="layout-center" checked />
                      <label for="layout-center"><span class="layout-option-title">Center focus</span><span class="layout-option-description">Hero element in the middle</span></label>
                    </div>
                    <div class="layout-option">
                      <input type="radio" name="layoutOption" value="scatter" id="layout-scatter" />
                      <label for="layout-scatter"><span class="layout-option-title">Scattered collage</span><span class="layout-option-description">Playful cluster with stickers and cutouts</span></label>
                    </div>
                    <div class="layout-option">
                      <input type="radio" name="layoutOption" value="border" id="layout-border" />
                      <label for="layout-border"><span class="layout-option-title">Border frame</span><span class="layout-option-description">Design wraps the edges with clear center</span></label>
                    </div>
                    <div class="layout-option">
                      <input type="radio" name="layoutOption" value="corner" id="layout-corner" />
                      <label for="layout-corner"><span class="layout-option-title">Corner tag</span><span class="layout-option-description">Statement badge in a single corner</span></label>
                    </div>
                  </fieldset>
                  <div class="finish-column">
                    <label for="overlayTextInput">Add text overlay</label>
                    <input id="overlayTextInput" type="text" placeholder="e.g., Luna, Stay Bold, or 1998" />
                    <label for="overlayIconUpload">Upload logo/picture</label>
                    <div class="overlay-upload">
                      <input id="overlayIconUpload" class="overlay-file-input" type="file" accept="image/png,image/jpeg,image/webp,image/svg+xml" />
                      <button id="overlayIconClear" class="overlay-remove-btn" type="button">Remove logo</button>
                      <div id="overlayIconPreview" class="overlay-preview" aria-live="polite">No logo added yet.</div>
                    </div>
                    <p class="ai-helper">PNG, JPG, WebP, or SVG up to 3MB.</p>
                    <p class="ai-helper">We will blend these into the AI prompt for you.</p>
                  </div>
                </div>
              </section>

              <section class="ai-step optional" aria-labelledby="ai-step-3">
                <div class="ai-step-label" id="ai-step-3">
                  <span class="ai-step-icon" aria-hidden="true">ðŸŸ¨</span>
                  <span class="ai-step-text">STEP 3 â€” SURPRISE ME!</span>
                </div>
                <p class="ai-helper">Not sure what to make? Shuffle to get a full vibe, layout, and effect you can tweak.</p>
                <button class="btn-ghost surprise-action" id="surpriseBtn" type="button">Shuffle a ready-made idea âœ¨</button>
              </section>

              <div class="ai-actions">
                <button id="generateBtn" class="btn-accent" type="button">Create Your Case Now</button>
                <p class="ai-helper">Tip: Press Cmd/Ctrl + Enter to generate fast.</p>
              </div>
              <div id="aiStatus" class="status" role="status" aria-live="polite"></div>
            </article>

            <article class="card" id="upload" aria-labelledby="upload-title">
              <div>
                <h3 id="upload-title">Upload your artwork</h3>
                <p class="card-subtitle">Drop in PNG, JPG, or WebP files up to 5MB. We'll keep everything crisp for print.</p>
              </div>
              <div id="dropZone" class="drop-zone" role="button" tabindex="0" aria-label="Drop image or browse">Drop image here or click to browse</div>
              <input id="fileInput" class="sr-only" type="file" accept="image/png,image/jpeg,image/webp" aria-hidden="true" />
              <div id="uploadStatus" class="status" role="status" aria-live="polite"></div>
            </article>
          </div>
        </section>

        <section class="workspace-section" id="controls" aria-labelledby="controls-title">
          <div class="section-heading">
            <h2 id="controls-title">Fine-tune every angle</h2>
            <p>Adjust scale, rotation, and opacity on the fly. Drag directly on the canvas or use the precision controls.</p>
          </div>
          <div class="card">
            <div class="controls-grid">
              <label class="control">Position
                <div id="dragHint">Drag design directly on canvas</div>
              </label>
              <label class="control">Scale
                <input id="scaleSlider" type="range" min="0.3" max="2.5" step="0.01" value="1" />
              </label>
              <label class="control">Rotation
                <input id="rotationSlider" type="range" min="-180" max="180" step="1" value="0" />
              </label>
              <label class="control">Opacity
                <input id="opacitySlider" type="range" min="0.2" max="1" step="0.01" value="1" />
              </label>
            </div>
            <label class="toggle">
              <span>Enable 3D preview</span>
              <input id="toggle3d" type="checkbox" />
            </label>
          </div>
        </section>

      </div>

      <aside class="preview-rail" aria-labelledby="preview-title">
        <div class="preview-stack">
          <section class="preview-card dark" id="preview">
            <div class="live-info">
              <span id="transformInfo">Scale 100% Â· Rotation 0Â° Â· Opacity 100%</span>
              <select id="phoneModel" aria-label="Select phone model">
                <option value="iphone15" selected>iPhone 15 Pro</option>
                <option value="iphone16">iPhone 16 Pro</option>
                <option value="samsung">Samsung Galaxy S24</option>
                <option value="pixel">Google Pixel 8 Pro</option>
              </select>
            </div>
            <div class="canvas-wrapper" id="canvasWrapper">
              <canvas id="phoneCanvas" width="400" height="800" aria-label="Phone case preview"></canvas>
              <div class="canvas-overlay"></div>
            </div>
          </section>

          <section class="final-card">
            <div class="final-card-header">
              <div>
                <h3>Ready when you are</h3>
                <p>Preview the print mask, export a production-ready PNG, or jump straight to checkout.</p>
              </div>
              <span class="final-card-badge">Â£19.99 Â· Free case + delivery</span>
            </div>
            <div class="final-card-actions">
              <div class="final-card-tools">
                <button class="btn-ghost btn-tool" id="previewBtn" type="button">Preview Mask</button>
                <button class="btn-accent btn-tool" id="downloadBtn" type="button">Download Design (PNG)</button>
              </div>
              <div class="order-callout">
                <p class="order-push">Your design slot is activeâ€”checkout now to print it today.</p>
                <a id="orderBtn" class="btn-order" href="checkout.html">Secure My Â£19.99 Case Now</a>
                <p class="order-note">Instant checkout. Free case & tracked delivery included.</p>
              </div>
            </div>
            <div id="exportStatus" class="status" role="status" aria-live="polite"></div>
          </section>
        </div>
      </aside>
    </div>
  </main>
  <footer>
    <div class="footer-band">
      <div class="footer-brand">
        <span class="footer-lockup" aria-hidden="true">
          <span class="brand-emblem">
            <svg class="brand-icon" viewBox="0 0 120 70" role="presentation" focusable="false">
              <defs>
                <linearGradient id="brand-peak-base-footer" x1="8%" y1="86%" x2="74%" y2="12%" gradientUnits="userSpaceOnUse">
                  <stop offset="0%" stop-color="#0a0d16" />
                  <stop offset="52%" stop-color="#1f2639" />
                  <stop offset="100%" stop-color="#39486a" />
                </linearGradient>
                <linearGradient id="brand-peak-glow-footer" x1="18%" y1="84%" x2="82%" y2="8%" gradientUnits="userSpaceOnUse">
                  <stop offset="0%" stop-color="#ffffff" stop-opacity="0.85" />
                  <stop offset="55%" stop-color="#ffffff" stop-opacity="0.45" />
                  <stop offset="100%" stop-color="#f2f4ff" stop-opacity="0" />
                </linearGradient>
              </defs>
              <path d="M7 58L36 22l14 20 10-12 23 24 15-12 17 30H7Z" fill="url(#brand-peak-base-footer)" />
              <path d="M36 22l14 20 10-12 7 8 11-9 8 27-19-18-9 7-12-16-10-7Z" fill="url(#brand-peak-glow-footer)" />
              <path d="M7 58L36 22l14 20 10-12 23 24 15-12 17 30" fill="none" stroke="rgba(255,255,255,0.6)" stroke-width="2" stroke-linejoin="round" />
            </svg>
          </span>
          <span class="brand-wordmark">EDGE</span>
        </span>
        <div class="footer-copy">
          <p class="footer-title">Edge Studio</p>
          <p class="footer-tagline">Climb past generic merch with AI-crafted, print-ready phone cases.</p>
        </div>
      </div>
      <div class="footer-actions">
        <a class="btn-ghost" href="#ai">Launch the Designer</a>
        <a class="btn-ghost" href="#upload">Upload Artwork</a>
      </div>
    </div>
    <p class="footer-note">Â© 2025 Edge â€” All rights reserved.</p>
  </footer>
  <script>
    (() => {
      const canvas = document.getElementById('phoneCanvas');
      const ctx = canvas.getContext('2d');
      const cornerRadius = 60;
      const generateBtn = document.getElementById('generateBtn');
      const promptInput = document.getElementById('promptInput');
      const aiStatus = document.getElementById('aiStatus');
      const dropZone = document.getElementById('dropZone');
      const fileInput = document.getElementById('fileInput');
      const uploadStatus = document.getElementById('uploadStatus');
      const scaleSlider = document.getElementById('scaleSlider');
      const rotationSlider = document.getElementById('rotationSlider');
      const opacitySlider = document.getElementById('opacitySlider');
      const transformInfo = document.getElementById('transformInfo');
      const previewBtn = document.getElementById('previewBtn');
      const downloadBtn = document.getElementById('downloadBtn');
      const exportStatus = document.getElementById('exportStatus');
      const canvasWrapper = document.getElementById('canvasWrapper');
      const preview3dContainer = document.getElementById('preview3d');
      const preview3dPlaceholder = document.getElementById('preview3dPlaceholder');
      const toggle3d = document.getElementById('toggle3d');
      const quickPromptButtons = document.querySelectorAll('[data-prompt]');
      const phoneModelSelect = document.getElementById('phoneModel');
      const phoneImageElem = document.getElementById('phoneImage');

      // Generate SVG phone case frame with model-specific camera layouts
      const createPhoneCaseSVG = (width, height, config) => {
        const { name, colorTint, cameraLayout, buttonLayout } = config;
        const cornerRadius = 60;
        const strokeWidth = 8;
        const id = name.replace(/\s+/g, '-');
        
        // Generate camera cutouts based on layout type
        let cameraSVG = '';
        if (cameraLayout.type === 'pill') {
          // iPhone style - Triangular/pill triple camera system
          const pillX = width * cameraLayout.x;
          const pillY = width * cameraLayout.y;
          const pillW = width * cameraLayout.width;
          const pillH = width * cameraLayout.height;
          
          // Create rounded square camera bump
          cameraSVG = `
            <!-- Camera bump housing -->
            <rect x="${pillX}" y="${pillY}" width="${pillW}" height="${pillH}" 
                  rx="22" fill="rgba(0,0,0,0.85)"/>
            <rect x="${pillX + 3}" y="${pillY + 3}" width="${pillW - 6}" height="${pillH - 6}" 
                  rx="19" fill="rgba(28,30,38,0.92)"/>
            
            <!-- Three camera lenses in triangle formation -->
            <circle cx="${pillX + pillW * 0.28}" cy="${pillY + pillH * 0.35}" r="${pillW * 0.14}" 
                    fill="rgba(10,12,18,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>
            <circle cx="${pillX + pillW * 0.72}" cy="${pillY + pillH * 0.35}" r="${pillW * 0.14}" 
                    fill="rgba(10,12,18,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>
            <circle cx="${pillX + pillW * 0.5}" cy="${pillY + pillH * 0.72}" r="${pillW * 0.14}" 
                    fill="rgba(10,12,18,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>
            
            <!-- LiDAR/Flash in corner -->
            <circle cx="${pillX + pillW * 0.82}" cy="${pillY + pillH * 0.78}" r="${pillW * 0.09}" 
                    fill="rgba(20,22,28,0.95)" stroke="rgba(255,255,255,0.08)" stroke-width="1.2"/>`;
                    
        } else if (cameraLayout.type === 'vertical') {
          // Samsung style - Individual lenses stacked vertically (no visible housing)
          const lensX = width * cameraLayout.x;
          const startY = height * cameraLayout.y;
          const lensRadius = width * cameraLayout.lensSize;
          const spacing = height * cameraLayout.spacing;
          
          cameraSVG = `
            <!-- Individual camera lenses (Samsung style) -->`;
          for (let i = 0; i < cameraLayout.count; i++) {
            const lensY = startY + (lensRadius * 2 + spacing) * i + lensRadius;
            cameraSVG += `
            <circle cx="${lensX + lensRadius}" cy="${lensY}" r="${lensRadius + 3}" 
                    fill="rgba(0,0,0,0.85)"/>
            <circle cx="${lensX + lensRadius}" cy="${lensY}" r="${lensRadius}" 
                    fill="rgba(15,17,22,0.98)" stroke="rgba(255,255,255,0.1)" stroke-width="1.5"/>`;
          }
          
        } else if (cameraLayout.type === 'bar') {
          // Pixel style - Horizontal camera bar
          const barX = width * cameraLayout.x;
          const barY = height * cameraLayout.y;
          const barW = width * cameraLayout.width;
          const barH = height * cameraLayout.height;
          cameraSVG = `
            <!-- Camera bar (Pixel signature design) -->
            <rect x="${barX}" y="${barY}" width="${barW}" height="${barH}" 
                  rx="16" fill="rgba(0,0,0,0.88)"/>
            <rect x="${barX + 4}" y="${barY + 4}" width="${barW - 8}" height="${barH - 8}" 
                  rx="12" fill="rgba(32,34,42,0.95)"/>
            
            <!-- Camera lenses in horizontal row -->
            <circle cx="${barX + barW * 0.22}" cy="${barY + barH / 2}" r="${barH * 0.28}" 
                    fill="rgba(12,14,20,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>
            <circle cx="${barX + barW * 0.50}" cy="${barY + barH / 2}" r="${barH * 0.28}" 
                    fill="rgba(12,14,20,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>
            <circle cx="${barX + barW * 0.78}" cy="${barY + barH / 2}" r="${barH * 0.28}" 
                    fill="rgba(12,14,20,0.98)" stroke="rgba(255,255,255,0.12)" stroke-width="1.8"/>`;
        }
        
        // Generate button cutouts
        let buttonsSVG = '';
        buttonLayout.forEach(btn => {
          const x = btn.side === 'left' ? 2 : width - 5;
          const y = height * btn.y;
          const h = height * btn.height;
          buttonsSVG += `
            <rect x="${x}" y="${y}" width="3" height="${h}" 
                  rx="1.5" fill="${colorTint}" opacity="0.9"/>`;
        });
        
        return `data:image/svg+xml;utf8,${encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${width} ${height}" width="${width}" height="${height}">
            <defs>
              <filter id="phoneShadow-${id}">
                <feGaussianBlur in="SourceAlpha" stdDeviation="12"/>
                <feOffset dx="0" dy="8" result="offsetblur"/>
                <feComponentTransfer>
                  <feFuncA type="linear" slope="0.4"/>
                </feComponentTransfer>
                <feMerge>
                  <feMergeNode/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
              <linearGradient id="caseGradient-${id}" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:${colorTint};stop-opacity:1" />
                <stop offset="50%" style="stop-color:rgba(28,30,40,0.98);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgba(18,20,28,0.95);stop-opacity:1" />
              </linearGradient>
              <radialGradient id="highlight-${id}" cx="30%" cy="20%">
                <stop offset="0%" style="stop-color:rgba(255,255,255,0.15);stop-opacity:1" />
                <stop offset="100%" style="stop-color:rgba(255,255,255,0);stop-opacity:1" />
              </radialGradient>
            </defs>
            
            <!-- Outer shadow -->
            <rect x="${strokeWidth}" y="${strokeWidth}" width="${width - strokeWidth * 2}" height="${height - strokeWidth * 2}" 
                  rx="${cornerRadius}" ry="${cornerRadius}" 
                  fill="rgba(0,0,0,0.6)" filter="url(#phoneShadow-${id})"/>
            
            <!-- Main case body -->
            <rect x="${strokeWidth}" y="${strokeWidth}" width="${width - strokeWidth * 2}" height="${height - strokeWidth * 2}" 
                  rx="${cornerRadius}" ry="${cornerRadius}" 
                  fill="url(#caseGradient-${id})" 
                  stroke="rgba(255,255,255,0.12)" 
                  stroke-width="${strokeWidth * 0.8}"/>
            
            <!-- Highlight overlay -->
            <rect x="${strokeWidth}" y="${strokeWidth}" width="${width - strokeWidth * 2}" height="${height - strokeWidth * 2}" 
                  rx="${cornerRadius}" ry="${cornerRadius}" 
                  fill="url(#highlight-${id})" opacity="0.6"/>
            
            <!-- Inner edge highlight -->
            <rect x="${strokeWidth * 1.5}" y="${strokeWidth * 1.5}" 
                  width="${width - strokeWidth * 3}" height="${height - strokeWidth * 3}" 
                  rx="${cornerRadius - 5}" ry="${cornerRadius - 5}" 
                  fill="none" 
                  stroke="rgba(255,255,255,0.08)" 
                  stroke-width="2"/>
            
            ${cameraSVG}
            ${buttonsSVG}
          </svg>
        `)}`;
      };

      // Phone model data with ACCURATE camera layouts based on real phone cases
      const phoneModels = {
        iphone15: { 
          name: 'iPhone 15 Pro', 
          width: 400, 
          height: 800,
          colorTint: 'rgba(50,55,70,0.95)', // Titanium blue
          cameraLayout: {
            type: 'pill', // Triangle pill camera bump (top-left corner)
            x: 0.04,      // 4% from left edge
            y: 0.025,     // 2.5% from top
            width: 0.32,  // 32% of width
            height: 0.12  // 12% of height (taller for vertical triangle)
          },
          buttonLayout: [
            { side: 'left', y: 0.13, height: 0.04 },  // Volume up
            { side: 'left', y: 0.19, height: 0.04 },  // Volume down
            { side: 'left', y: 0.26, height: 0.018 }, // Mute/Action switch
            { side: 'right', y: 0.35, height: 0.11 }  // Power button
          ],
          image: null
        },
        iphone16: { 
          name: 'iPhone 16 Pro', 
          width: 400, 
          height: 820,
          colorTint: 'rgba(60,50,70,0.95)', // Desert titanium
          cameraLayout: {
            type: 'pill',  // Larger triangle pill camera bump
            x: 0.04,
            y: 0.024,
            width: 0.34,   // Slightly larger than 15 Pro
            height: 0.13
          },
          buttonLayout: [
            { side: 'left', y: 0.125, height: 0.038 }, // Volume up
            { side: 'left', y: 0.182, height: 0.038 }, // Volume down
            { side: 'left', y: 0.25, height: 0.015 },  // Mute switch
            { side: 'right', y: 0.16, height: 0.022 }, // Camera control button
            { side: 'right', y: 0.33, height: 0.13 }   // Power/Action button
          ],
          image: null
        },
        samsung: { 
          name: 'Samsung Galaxy S24', 
          width: 390, 
          height: 810,
          colorTint: 'rgba(45,55,50,0.95)', // Samsung black
          cameraLayout: {
            type: 'vertical', // Individual lenses stacked vertically (no housing)
            x: 0.06,
            y: 0.035,
            lensSize: 0.055,  // Size of each individual lens
            spacing: 0.018,    // Space between lenses
            count: 3           // Three lenses
          },
          buttonLayout: [
            { side: 'right', y: 0.20, height: 0.075 }, // Volume rocker
            { side: 'right', y: 0.31, height: 0.065 }  // Power button
          ],
          image: null
        },
        pixel: { 
          name: 'Google Pixel 8 Pro', 
          width: 395, 
          height: 815,
          colorTint: 'rgba(55,50,45,0.95)', // Pixel obsidian
          cameraLayout: {
            type: 'bar', // Horizontal camera bar (signature Pixel design)
            x: 0.05,
            y: 0.028,
            width: 0.90,   // Extends almost full width
            height: 0.08   // Prominent bar height
          },
          buttonLayout: [
            { side: 'right', y: 0.26, height: 0.08 },  // Volume
            { side: 'right', y: 0.39, height: 0.058 }  // Power
          ],
          image: null
        }
      };

      // Generate SVG images for all models with realistic layouts
      Object.keys(phoneModels).forEach(key => {
        const model = phoneModels[key];
        model.image = createPhoneCaseSVG(model.width, model.height, {
          name: model.name,
          colorTint: model.colorTint,
          cameraLayout: model.cameraLayout,
          buttonLayout: model.buttonLayout
        });
      });

      

      const VIBE_CATEGORIES = [
        {
          id: 'art-aesthetics',
          name: 'Art & Aesthetics',
          emoji: 'ðŸŽ¨',
          description: 'Painterly blends, Y2K sheen, vaporwave glow, or stripped-down brutalist grids.',
          tags: ['Y2K', 'Vaporwave', 'Minimal', 'Painterly'],
          stylePrompt: 'artistic color blocking, confident gradients, and gallery-ready typography',
          preview: {
            gradient: ['#FF9DE4', '#6C5CE7'],
            shapes: [
              { type: 'circle', x: 0.28, y: 0.32, radius: 0.28, color: 'rgba(255, 210, 102, 0.45)', blur: 70 },
              { type: 'stripe', angle: -18, thickness: 0.22, color: 'rgba(255, 255, 255, 0.12)' },
              { type: 'ring', x: 0.68, y: 0.65, radius: 0.22, lineWidth: 0.05, color: 'rgba(108, 92, 231, 0.55)' }
            ],
            overlayText: 'Art Mode'
          }
        },
        {
          id: 'pop-culture-icons',
          name: 'Pop Culture & Icons',
          emoji: 'ðŸ•¹ï¸',
          description: 'Anime energy, retro tech, streetwear graphics, and bold cartoon mashups.',
          tags: ['Anime', 'Retro', 'Streetwear', 'Playful'],
          stylePrompt: 'bold iconography, sticker layering, and high-contrast outlines',
          preview: {
            gradient: ['#FF6B6B', '#39C0FF'],
            shapes: [
              { type: 'circle', x: 0.3, y: 0.28, radius: 0.24, color: 'rgba(255, 255, 255, 0.18)', blur: 40 },
              { type: 'stripe', angle: 22, thickness: 0.18, color: 'rgba(255, 214, 102, 0.3)' },
              { type: 'dots', offsetX: 0.68, offsetY: 0.62, spread: 0.22, count: 5, radius: 0.04, color: 'rgba(0, 0, 0, 0.25)' }
            ],
            overlayText: 'Pop Pop'
          }
        },
        {
          id: 'nature-landscapes',
          name: 'Nature & Landscapes',
          emoji: 'ðŸŒ„',
          description: 'Mountains, oceans, forests, skies, and calming cosmic horizons.',
          tags: ['Coastal', 'Forests', 'Skies', 'Organic'],
          stylePrompt: 'lush gradients, misty atmosphere, and organic layering',
          preview: {
            gradient: ['#0B3D2E', '#68C4A3'],
            shapes: [
              { type: 'circle', x: 0.72, y: 0.28, radius: 0.22, color: 'rgba(255, 237, 160, 0.45)', blur: 50 },
              { type: 'stripe', angle: -12, thickness: 0.16, color: 'rgba(12, 61, 49, 0.4)' },
              { type: 'dots', offsetX: 0.35, offsetY: 0.68, spread: 0.2, count: 6, radius: 0.03, color: 'rgba(255, 255, 255, 0.22)' }
            ],
            overlayText: 'Wander'
          }
        },
        {
          id: 'fantasy-myth',
          name: 'Fantasy & Myth',
          emoji: 'ðŸ”®',
          description: 'Dragons, angels, tarot, celestial portals, and legendary realms.',
          tags: ['Tarot', 'Cosmic', 'Mystic', 'Epic'],
          stylePrompt: 'mythic lighting, ethereal glow, and ornate detailing',
          preview: {
            gradient: ['#1D0A3C', '#8F57FF'],
            shapes: [
              { type: 'circle', x: 0.26, y: 0.66, radius: 0.26, color: 'rgba(118, 220, 255, 0.3)', blur: 60 },
              { type: 'stripe', angle: 35, thickness: 0.16, color: 'rgba(255, 255, 255, 0.1)' },
              { type: 'ring', x: 0.7, y: 0.32, radius: 0.2, lineWidth: 0.04, color: 'rgba(255, 204, 255, 0.55)' }
            ],
            overlayText: 'Mythic'
          }
        },
        {
          id: 'personal-identity',
          name: 'Personal & Identity',
          emoji: 'ðŸ’–',
          description: 'Names, initials, slogans, pets, astrology, and personal symbols.',
          tags: ['Monogram', 'Zodiac', 'Pets', 'Quotes'],
          stylePrompt: 'personalized lettering, clean shapes, and soft gradients',
          preview: {
            gradient: ['#FDBA74', '#F472B6'],
            shapes: [
              { type: 'circle', x: 0.32, y: 0.35, radius: 0.24, color: 'rgba(255, 255, 255, 0.18)', blur: 40 },
              { type: 'stripe', angle: -24, thickness: 0.18, color: 'rgba(255, 255, 255, 0.1)' },
              { type: 'ring', x: 0.68, y: 0.68, radius: 0.2, lineWidth: 0.04, color: 'rgba(255, 255, 255, 0.45)' }
            ],
            overlayText: 'Signature'
          }
        },
        {
          id: 'collage-chaos',
          name: 'Collage & Chaos',
          emoji: 'ðŸŒ€',
          description: 'Stickerbomb energy, surreal mashups, glitch layers, and bold cutouts.',
          tags: ['Sticker', 'Graffiti', 'Surreal', 'Remix'],
          stylePrompt: 'chaotic collage, layered stickers, and energetic scribbles',
          preview: {
            gradient: ['#111827', '#EF4444'],
            shapes: [
              { type: 'dots', offsetX: 0.3, offsetY: 0.35, spread: 0.25, count: 7, radius: 0.035, color: 'rgba(255, 255, 255, 0.3)' },
              { type: 'stripe', angle: 15, thickness: 0.2, color: 'rgba(239, 68, 68, 0.3)' },
              { type: 'ring', x: 0.72, y: 0.65, radius: 0.24, lineWidth: 0.05, color: 'rgba(253, 224, 71, 0.45)' }
            ],
            overlayText: 'Remix'
          }
        }
      ];

      const LAYOUT_OPTIONS = [
        {
          id: 'center',
          label: 'Center focus',
          prompt: 'a center-focused layout highlighting the primary subject',
          preview: { textX: 0.5, textY: 0.55, align: 'center', iconX: 0.5, iconY: 0.28 }
        },
        {
          id: 'scatter',
          label: 'Scattered collage',
          prompt: 'a playful scattered composition with layered stickers',
          preview: { textX: 0.26, textY: 0.38, align: 'left', iconX: 0.68, iconY: 0.65 }
        },
        {
          id: 'border',
          label: 'Border frame',
          prompt: 'a border-framed layout that hugs the edges and leaves breathing room in the middle',
          preview: { textX: 0.5, textY: 0.85, align: 'center', iconX: 0.5, iconY: 0.2 }
        },
        {
          id: 'corner',
          label: 'Corner tag',
          prompt: 'a corner badge feature with supporting accents around it',
          preview: { textX: 0.72, textY: 0.78, align: 'right', iconX: 0.28, iconY: 0.28 }
        }
      ];

      const SURPRISE_PRESETS = [
      {
        prompt: 'retro arcade skyline with neon scoreboards and glitch haze',
        vibeId: 'pop-culture-icons',
        layout: 'scatter',
        overlayText: 'Level Up'
      },
      {
        prompt: 'misty mountains at sunrise with koi fish clouds',
        vibeId: 'nature-landscapes',
        layout: 'border',
        overlayText: 'Wander'
      },
      {
        prompt: 'cosmic dragon guarding a crystal tarot portal',
        vibeId: 'fantasy-myth',
        layout: 'center',
        overlayText: 'Mythic'
      },
      {
        prompt: 'collage of vintage magazines, doodle faces, and graffiti streaks',
        vibeId: 'collage-chaos',
        layout: 'scatter',
        overlayText: 'Remix'
      },
      {
        prompt: 'soft blush gradient with minimalist monogram and gold foil flecks',
        vibeId: 'personal-identity',
        layout: 'corner',
        overlayText: 'AB'
      },
      {
        prompt: 'dreamy vaporwave sunset grid with chrome statues and palm trees',
        vibeId: 'art-aesthetics',
        layout: 'center',
        overlayText: 'Paradise'
      }
      ];

      const DEFAULT_OVERLAY_MESSAGE = 'No logo added yet.';
      const DEFAULT_REFERENCE_MESSAGE = 'No reference image added yet.';

      const randomFrom = (arr) => arr[Math.floor(Math.random() * arr.length)];

      const vibePrevBtn = document.getElementById('vibePrevBtn');
      const vibeNextBtn = document.getElementById('vibeNextBtn');
      const vibeName = document.getElementById('vibeName');
      const vibeDescription = document.getElementById('vibeDescription');
      const vibeTags = document.getElementById('vibeTags');
      const vibeCase = document.getElementById('vibeCase');
      const vibeDots = document.getElementById('vibeDots');
      const overlayTextInput = document.getElementById('overlayTextInput');
      const overlayIconUpload = document.getElementById('overlayIconUpload');
      const overlayIconClear = document.getElementById('overlayIconClear');
      const overlayIconPreview = document.getElementById('overlayIconPreview');
      const promptReferenceUpload = document.getElementById('promptReferenceUpload');
      const promptReferenceClear = document.getElementById('promptReferenceClear');
      const promptReferencePreview = document.getElementById('promptReferencePreview');
      const layoutRadios = document.querySelectorAll('input[name="layoutOption"]');
      const surpriseBtn = document.getElementById('surpriseBtn');
      // API endpoint now points to our secure Next.js API route
      const GEMINI_ENDPOINT = '/api/generate-design';
      const RATE_LIMIT_FALLBACK_MS = 45_000;
      let rateLimitUntil = 0;

      // Centralized UI and rendering state
      const state = {
        image: null,
        imageBitmap: null,
        baseScale: 1,
        transform: {
          scale: 1,
          rotation: 0,
          opacity: 1,
          x: canvas.width / 2,
          y: canvas.height / 2,
        },
        dragging: false,
        dragStart: { x: 0, y: 0 },
        initialPos: { x: 0, y: 0 },
        needsRender: true,
        showMask: false,
        vibePreviewActive: false,
        showEdgeDefault: true,
        selections: {
          vibeIndex: 0,
          layout: 'center',
          overlayText: '',
        },
        customOverlay: {
          bitmap: null,
          objectUrl: '',
          name: '',
        },
        referenceImage: {
          base64: '',
          mimeType: '',
          name: '',
          dataUrl: '',
          signature: '',
        },
        edgeLogoImage: null,
        three: {
          enabled: false,
          scene: null,
          renderer: null,
          camera: null,
          controls: null,
          mesh: null,
          texture: null,
          raf: 0,
        },
      };

      const vibeDotsButtons = [];

      // Path2D mask keeps artwork perfectly contained within the case outline
      const createPhoneMask = (width, height, corner, cameraLayout) => {
        const outer = new Path2D();
        outer.moveTo(corner, 0);
        outer.lineTo(width - corner, 0);
        outer.quadraticCurveTo(width, 0, width, corner);
        outer.lineTo(width, height - corner);
        outer.quadraticCurveTo(width, height, width - corner, height);
        outer.lineTo(corner, height);
        outer.quadraticCurveTo(0, height, 0, height - corner);
        outer.lineTo(0, corner);
        outer.quadraticCurveTo(0, 0, corner, 0);
        outer.closePath();

        // Create camera cutout path based on layout type
        const cameraPath = new Path2D();
        if (cameraLayout.type === 'pill') {
          const pillX = width * cameraLayout.x;
          const pillY = width * cameraLayout.y;
          const pillW = width * cameraLayout.width;
          const pillH = width * cameraLayout.height;
          cameraPath.roundRect(pillX, pillY, pillW, pillH, 22);
        } else if (cameraLayout.type === 'vertical') {
          // Samsung style - individual circular lenses
          const lensX = width * cameraLayout.x;
          const startY = height * cameraLayout.y;
          const lensRadius = width * cameraLayout.lensSize;
          const spacing = height * cameraLayout.spacing;
          
          for (let i = 0; i < cameraLayout.count; i++) {
            const lensY = startY + (lensRadius * 2 + spacing) * i + lensRadius;
            cameraPath.arc(lensX + lensRadius, lensY, lensRadius + 3, 0, Math.PI * 2);
          }
        } else if (cameraLayout.type === 'bar') {
          const barX = width * cameraLayout.x;
          const barY = height * cameraLayout.y;
          const barW = width * cameraLayout.width;
          const barH = height * cameraLayout.height;
          cameraPath.roundRect(barX, barY, barW, barH, 16);
        }

        const path = new Path2D();
        path.addPath(outer);
        path.addPath(cameraPath);

        return {
          path,
          outer,
          camera: cameraLayout,
          clipRule: 'evenodd',
        };
      };
      
      let phoneMask = createPhoneMask(canvas.width, canvas.height, cornerRadius, phoneModels.iphone15.cameraLayout);

      // Pre-rendered lighting overlay keeps the case feeling three-dimensional while allowing transparent background
      const createCaseLightingOverlay = (width, height, mask) => {
        const overlay = document.createElement('canvas');
        overlay.width = width;
        overlay.height = height;
        const gctx = overlay.getContext('2d');

        const { path: maskPath, clipRule, outer, camera } = mask;

        gctx.save();
        gctx.clip(maskPath, clipRule);

        // Subtle vignette darkens the wrapped edges so artwork feels like it hugs the case
        const edgeDarken = gctx.createRadialGradient(
          width / 2,
          height / 2,
          Math.min(width, height) * 0.35,
          width / 2,
          height / 2,
          Math.max(width, height) * 0.65
        );
        edgeDarken.addColorStop(0, 'rgba(0, 0, 0, 0)');
        edgeDarken.addColorStop(1, 'rgba(0, 0, 0, 0.38)');
        gctx.fillStyle = edgeDarken;
        gctx.fillRect(0, 0, width, height);

        // Soft vertical highlight simulates a light source sweeping across the curvature
        const verticalSheen = gctx.createLinearGradient(0, 0, 0, height);
        verticalSheen.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
        verticalSheen.addColorStop(0.25, 'rgba(255, 255, 255, 0.05)');
        verticalSheen.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
        verticalSheen.addColorStop(0.85, 'rgba(0, 0, 0, 0.25)');
        verticalSheen.addColorStop(1, 'rgba(0, 0, 0, 0.35)');
        gctx.fillStyle = verticalSheen;
        gctx.globalCompositeOperation = 'lighter';
        gctx.fillRect(0, 0, width, height);

        // Edge glows add a sense of polish along left/right rails
        gctx.globalCompositeOperation = 'source-over';
        const horizontalSheen = gctx.createLinearGradient(0, 0, width, 0);
        horizontalSheen.addColorStop(0, 'rgba(255, 255, 255, 0.26)');
        horizontalSheen.addColorStop(0.12, 'rgba(255, 255, 255, 0.02)');
        horizontalSheen.addColorStop(0.88, 'rgba(0, 0, 0, 0.18)');
        horizontalSheen.addColorStop(1, 'rgba(0, 0, 0, 0.32)');
        gctx.fillStyle = horizontalSheen;
        gctx.fillRect(0, 0, width, height);

        gctx.restore();

        // Crisp rim strokes enhance definition without adding opaque background pixels
        gctx.lineJoin = 'round';
        gctx.lineCap = 'round';
        gctx.lineWidth = 2.4;
        gctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        gctx.stroke(outer);
        gctx.lineWidth = 6;
        gctx.strokeStyle = 'rgba(0, 0, 0, 0.45)';
        gctx.stroke(outer);

        // Camera module detail (simplified for new layouts)
        if (camera && camera.type) {
          gctx.save();
          gctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
          gctx.shadowBlur = 8;
          gctx.fillStyle = 'rgba(12, 14, 22, 0.6)';
          
          // Draw shadow based on camera type
          if (camera.type === 'pill') {
            const pillX = width * camera.x;
            const pillY = width * camera.y;
            const pillW = width * camera.width;
            const pillH = width * camera.height;
            gctx.beginPath();
            gctx.roundRect(pillX, pillY, pillW, pillH, 22);
            gctx.fill();
          } else if (camera.type === 'vertical') {
            // Samsung - individual lenses
            const lensX = width * camera.x;
            const startY = height * camera.y;
            const lensRadius = width * camera.lensSize;
            const spacing = height * camera.spacing;
            
            for (let i = 0; i < camera.count; i++) {
              const lensY = startY + (lensRadius * 2 + spacing) * i + lensRadius;
              gctx.beginPath();
              gctx.arc(lensX + lensRadius, lensY, lensRadius + 3, 0, Math.PI * 2);
              gctx.fill();
            }
          } else if (camera.type === 'bar') {
            const barX = width * camera.x;
            const barY = height * camera.y;
            const barW = width * camera.width;
            const barH = height * camera.height;
            gctx.beginPath();
            gctx.roundRect(barX, barY, barW, barH, 16);
            gctx.fill();
          }
          gctx.restore();
        }

        return overlay;
      };
      
      let caseLightingOverlay = createCaseLightingOverlay(canvas.width, canvas.height, phoneMask);

      const EDGE_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 70"><path d="M7 58L36 22l14 20 10-12 23 24 15-12 17 30H7Z" fill="#ff6b36"/><path d="M36 22l14 20 10-12 23 24 15-12 17 30" fill="none" stroke="#ffffff" stroke-opacity="0.82" stroke-width="4" stroke-linejoin="round"/></svg>';
      const EDGE_LOGO_DATA_URL = `data:image/svg+xml;utf8,${encodeURIComponent(EDGE_LOGO_SVG)}`;

      const debounce = (fn, delay = 300) => {
        let timer;
        return (...args) => {
          clearTimeout(timer);
          timer = setTimeout(() => fn.apply(null, args), delay);
        };
      };

      const clipToPhoneMask = (context) => {
        context.clip(phoneMask.path, phoneMask.clipRule);
      };

      const ensureEdgeLogoImage = () => {
        if (state.edgeLogoImage) {
          return state.edgeLogoImage;
        }
        const img = new Image();
        img.onload = () => {
          state.edgeLogoImage = img;
          state.needsRender = true;
        };
        img.onerror = (err) => {
          console.warn('Edge logo failed to load', err);
        };
        img.src = EDGE_LOGO_DATA_URL;
        return null;
      };

      const setLoading = (isLoading) => {
        if (isLoading) {
          generateBtn.disabled = true;
          generateBtn.innerHTML = '<span class="loading"><span class="spinner" aria-hidden="true"></span>Generatingâ€¦</span>';
        } else {
          generateBtn.disabled = false;
          generateBtn.textContent = 'Create Your Case Now';
        }
      };

      const setStatus = (element, message, type = 'info') => {
        if (!element) return;
        element.textContent = message;
        element.classList.remove('error', 'success', 'warning');
        if (type !== 'info') {
          element.classList.add(type);
        }
      };

      const updateTransformInfo = () => {
        const { scale, rotation, opacity } = state.transform;
        const scalePercent = Math.round(scale * 100);
        const opacityPercent = Math.round(opacity * 100);
        transformInfo.textContent = `Scale ${scalePercent}% Â· Rotation ${Math.round(rotation)}Â° Â· Opacity ${opacityPercent}%`;
      };

      const clearCanvas = () => {
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.globalAlpha = 1;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Always fill with opaque white to prevent SVG showing through
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
      };

      const drawCaseOverlay = () => {
        ctx.save();
        ctx.drawImage(caseLightingOverlay, 0, 0);
        ctx.restore();
      };

      const drawDesign = () => {
        if (!state.imageBitmap && !state.customOverlay?.bitmap) return;
        ctx.save();
        clipToPhoneMask(ctx);
        if (state.imageBitmap) {
          ctx.save();
          ctx.translate(state.transform.x, state.transform.y);
          ctx.rotate((state.transform.rotation * Math.PI) / 180);
          const scale = state.baseScale * state.transform.scale;
          ctx.scale(scale, scale);
          ctx.globalAlpha = state.transform.opacity;
          ctx.drawImage(state.imageBitmap, -state.imageBitmap.width / 2, -state.imageBitmap.height / 2);
          ctx.restore();
        }
        if (state.customOverlay?.bitmap) {
          drawCustomOverlay(ctx);
        }
        ctx.restore();
      };

      const drawEdgeFallback = () => {
        ctx.save();
        clipToPhoneMask(ctx);

        const baseGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        baseGradient.addColorStop(0, '#050608');
        baseGradient.addColorStop(1, '#0b0d15');
        ctx.fillStyle = baseGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const radialGlow = ctx.createRadialGradient(
          canvas.width / 2,
          canvas.height * 0.4,
          canvas.width * 0.08,
          canvas.width / 2,
          canvas.height * 0.42,
          canvas.width * 0.7
        );
        radialGlow.addColorStop(0, 'rgba(255, 77, 31, 0.32)');
        radialGlow.addColorStop(1, 'rgba(255, 77, 31, 0)');
        ctx.fillStyle = radialGlow;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const sweep = ctx.createLinearGradient(0, canvas.height * 0.18, 0, canvas.height * 0.82);
        sweep.addColorStop(0, 'rgba(255, 255, 255, 0.08)');
        sweep.addColorStop(0.5, 'rgba(255, 255, 255, 0)');
        sweep.addColorStop(1, 'rgba(255, 255, 255, 0.08)');
        ctx.globalCompositeOperation = 'lighter';
        ctx.fillStyle = sweep;
        ctx.fillRect(0, canvas.height * 0.18, canvas.width, canvas.height * 0.64);
        ctx.globalCompositeOperation = 'source-over';

        const logoImg = ensureEdgeLogoImage();
        if (logoImg) {
          const maxWidth = canvas.width * 0.56;
          const maxHeight = canvas.height * 0.32;
          const scale = Math.min(maxWidth / logoImg.width, maxHeight / logoImg.height);
          const logoWidth = logoImg.width * scale;
          const logoHeight = logoImg.height * scale;
          const logoX = (canvas.width - logoWidth) / 2;
          const logoY = canvas.height * 0.46 - logoHeight / 2;
          ctx.shadowColor = 'rgba(255, 77, 31, 0.32)';
          ctx.shadowBlur = 36;
          ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
          ctx.shadowBlur = 0;
        }

        ctx.restore();
      };

      const getActiveVibe = () => {
        if (!Array.isArray(VIBE_CATEGORIES) || VIBE_CATEGORIES.length === 0) return null;
        const index = Math.max(0, Math.min(state.selections.vibeIndex, VIBE_CATEGORIES.length - 1));
        return VIBE_CATEGORIES[index];
      };

      const getSelectedLayout = () => LAYOUT_OPTIONS.find((layout) => layout.id === state.selections.layout) || LAYOUT_OPTIONS[0];

      const drawCustomOverlay = (ctx) => {
        const overlay = state.customOverlay?.bitmap;
        if (!overlay) return;
        const layout = getSelectedLayout();
        const maxWidth = canvas.width * 0.4;
        const maxHeight = canvas.height * 0.4;
        const scale = Math.min(maxWidth / overlay.width, maxHeight / overlay.height, 1);
        const drawWidth = overlay.width * scale;
        const drawHeight = overlay.height * scale;
        const iconX = (layout?.preview?.iconX ?? 0.5) * canvas.width;
        const iconY = (layout?.preview?.iconY ?? 0.3) * canvas.height;
        ctx.save();
        ctx.shadowColor = 'rgba(0, 0, 0, 0.32)';
        ctx.shadowBlur = 18;
        ctx.globalAlpha = 1;
        ctx.drawImage(overlay, iconX - drawWidth / 2, iconY - drawHeight / 2, drawWidth, drawHeight);
        ctx.restore();
      };

      const updateVibeDisplay = () => {
        const vibe = getActiveVibe();
        if (!vibe) return;
        if (vibeName) vibeName.textContent = `${vibe.emoji} ${vibe.name}`;
        if (vibeDescription) vibeDescription.textContent = vibe.description;
        if (vibeTags) {
          vibeTags.innerHTML = '';
          vibe.tags?.forEach((tag) => {
            const tagEl = document.createElement('span');
            tagEl.className = 'vibe-tag';
            tagEl.textContent = tag;
            vibeTags.append(tagEl);
          });
        }
        if (vibeCase) {
          if (Array.isArray(vibe.preview?.gradient)) {
            const [start, end] = vibe.preview.gradient;
            vibeCase.style.background = `linear-gradient(140deg, ${start}, ${end || start})`;
          }
          vibeCase.innerHTML = '';
          const label = document.createElement('span');
          label.className = 'vibe-case-label';
          label.textContent = vibe.preview?.overlayText || vibe.name;
          vibeCase.append(label);
        }
        vibeDotsButtons.forEach((dot, idx) => {
          dot.classList.toggle('active', idx === state.selections.vibeIndex);
          dot.setAttribute('aria-pressed', idx === state.selections.vibeIndex ? 'true' : 'false');
        });
      };

      const setVibeIndex = (index, options = {}) => {
        const { activatePreview = true } = options;
        if (!Array.isArray(VIBE_CATEGORIES) || VIBE_CATEGORIES.length === 0) return;
        const total = VIBE_CATEGORIES.length;
        const normalized = ((index % total) + total) % total;
        state.selections.vibeIndex = normalized;
        if (activatePreview) {
          state.showEdgeDefault = false;
        }
        if (!state.imageBitmap) {
          state.vibePreviewActive = activatePreview;
        }
        updateVibeDisplay();
        state.needsRender = true;
      };

      const cycleVibe = (delta) => {
        setVibeIndex(state.selections.vibeIndex + delta);
      };

      const drawVibePreview = () => {
        const vibe = getActiveVibe();
        ctx.save();
        clipToPhoneMask(ctx);
        const minDim = Math.min(canvas.width, canvas.height);
        const gradientColors = vibe?.preview?.gradient || ['#1f2937', '#0b1120'];
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, gradientColors[0]);
        gradient.addColorStop(1, gradientColors[1] || gradientColors[0]);
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const shapes = Array.isArray(vibe?.preview?.shapes) ? vibe.preview.shapes : [];
        shapes.forEach((shape, idx) => {
          if (!shape || !shape.type) return;
          const type = shape.type;
          if (type === 'circle') {
            ctx.save();
            const radius = (shape.radius || 0.24) * minDim;
            const x = (shape.x || 0.5) * canvas.width;
            const y = (shape.y || 0.5) * canvas.height;
            ctx.fillStyle = shape.color || 'rgba(255, 255, 255, 0.18)';
            if (shape.blur) {
              ctx.shadowColor = shape.color || 'rgba(255, 255, 255, 0.18)';
              ctx.shadowBlur = shape.blur;
            }
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
          } else if (type === 'stripe') {
            ctx.save();
            const angle = ((shape.angle || 0) * Math.PI) / 180;
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(angle);
            const thickness = (shape.thickness || 0.18) * minDim;
            ctx.fillStyle = shape.color || 'rgba(255, 255, 255, 0.08)';
            ctx.fillRect(-canvas.width, -thickness / 2, canvas.width * 2, thickness);
            ctx.restore();
          } else if (type === 'ring') {
            ctx.save();
            const radius = (shape.radius || 0.2) * minDim;
            const lineWidth = (shape.lineWidth || 0.04) * minDim;
            const x = (shape.x || 0.5) * canvas.width;
            const y = (shape.y || 0.5) * canvas.height;
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = shape.color || 'rgba(255, 255, 255, 0.28)';
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          } else if (type === 'dots') {
            ctx.save();
            const count = Math.max(1, shape.count || 5);
            const spread = shape.spread || 0.2;
            const offsetX = (shape.offsetX || 0.5) * canvas.width;
            const offsetY = (shape.offsetY || 0.5) * canvas.height;
            const radius = (shape.radius || 0.03) * minDim;
            ctx.fillStyle = shape.color || 'rgba(255, 255, 255, 0.2)';
            for (let i = 0; i < count; i += 1) {
              const angle = (i / count) * Math.PI * 2;
              const x = offsetX + Math.cos(angle) * spread * canvas.width;
              const y = offsetY + Math.sin(angle) * spread * canvas.height;
              ctx.beginPath();
              ctx.arc(x, y, radius, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }
        });

        const layout = getSelectedLayout();
        const displayText = (state.selections.overlayText || '').trim() || vibe?.preview?.overlayText || '';
        if (displayText) {
          ctx.save();
          ctx.fillStyle = 'rgba(255, 255, 255, 0.92)';
          const fontSize = Math.max(28, minDim * 0.08);
          ctx.font = `600 ${fontSize}px "Plus Jakarta Sans", "Inter", sans-serif`;
          ctx.textBaseline = 'middle';
          ctx.textAlign = layout?.preview?.align || 'center';
          const textX = (layout?.preview?.textX ?? 0.5) * canvas.width;
          const textY = (layout?.preview?.textY ?? 0.55) * canvas.height;
          ctx.shadowColor = 'rgba(0, 0, 0, 0.35)';
          ctx.shadowBlur = 20;
          ctx.fillText(displayText, textX, textY);
          ctx.restore();
        }

        drawCustomOverlay(ctx);

        ctx.restore();
      };

      const render = () => {
        if (!state.needsRender) return;
        state.needsRender = false;
        clearCanvas();
        const hasDesign = Boolean(state.imageBitmap || state.customOverlay?.bitmap);
        if (hasDesign) {
          drawDesign();
        } else if (state.showEdgeDefault) {
          drawEdgeFallback();
        } else if (state.vibePreviewActive) {
          drawVibePreview();
        }
        drawCaseOverlay();
        update3DTexture();
      };

      // requestAnimationFrame loop repaints only when the state is marked dirty
      const renderLoop = () => {
        render();
        requestAnimationFrame(renderLoop);
      };

      const resetTransform = () => {
        state.transform.scale = 1;
        state.transform.rotation = 0;
        state.transform.opacity = 1;
        state.transform.x = canvas.width / 2;
        state.transform.y = canvas.height / 2;
        scaleSlider.value = '1';
        rotationSlider.value = '0';
        opacitySlider.value = '1';
        updateTransformInfo();
      };

      const createImageBitmapSafe = async (img) => {
        try {
          if ('createImageBitmap' in window) {
            return await createImageBitmap(img);
          }
        } catch (err) {
          console.warn('createImageBitmap failed, falling back to <img>', err);
        }
        const canvasTemp = document.createElement('canvas');
        canvasTemp.width = img.width;
        canvasTemp.height = img.height;
        const tempCtx = canvasTemp.getContext('2d');
        tempCtx.drawImage(img, 0, 0);
        return canvasTemp;
      };

      const applyImage = async (img, options = {}) => {
        const { focusPreview = false } = options;
        state.image = img;
        state.imageBitmap = await createImageBitmapSafe(img);
        state.vibePreviewActive = false;
        state.showEdgeDefault = false;
        const coverScale = Math.max(canvas.width / img.width, canvas.height / img.height);
        state.baseScale = coverScale;
        resetTransform();
        state.needsRender = true;
        update3DTexture();
        if (focusPreview && typeof canvasWrapper.scrollIntoView === 'function') {
          requestAnimationFrame(() => {
            canvasWrapper.scrollIntoView({ behavior: 'smooth', block: 'center' });
          });
        }
      };

      const loadImageFromSource = (src, sourceLabel = 'design') => {
        return new Promise((resolve, reject) => {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => resolve(img);
          img.onerror = () => reject(new Error(`Unable to load ${sourceLabel}`));
          img.src = src;
        });
      };

      const validateFile = (file) => {
        const allowed = ['image/png', 'image/jpeg', 'image/webp'];
        if (!allowed.includes(file.type)) {
          throw new Error('Unsupported format. Use PNG, JPG, or WebP.');
        }
        if (file.size > 5 * 1024 * 1024) {
          throw new Error('File too large. Max 5MB.');
        }
      };

      const validateOverlayFile = (file) => {
        const allowed = ['image/png', 'image/jpeg', 'image/webp', 'image/svg+xml'];
        if (!allowed.includes(file.type)) {
          throw new Error('Logo must be PNG, JPG, WebP, or SVG.');
        }
        if (file.size > 3 * 1024 * 1024) {
          throw new Error('Logo too large. Keep it under 3MB.');
        }
      };

      const handleFile = async (file) => {
        try {
          validateFile(file);
          setStatus(uploadStatus, 'Loading imageâ€¦');
          const dataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsDataURL(file);
          });
          const img = await loadImageFromSource(dataUrl, file.name);
          await applyImage(img, { focusPreview: true });
          setStatus(uploadStatus, `âœ“ ${file.name} loaded successfully!`, 'success');
          setTimeout(() => setStatus(uploadStatus, 'Drag to reposition or adjust with sliders.'), 2000);
        } catch (err) {
          console.error(err);
          setStatus(uploadStatus, err.message, 'error');
        }
      };

      const setPreviewContent = (target, content) => {
        if (!target) return;
        target.innerHTML = '';
        if (typeof content === 'string') {
          target.textContent = content;
        } else if (content instanceof Node) {
          target.append(content);
        }
      };

      const setOverlayPreviewContent = (content) => {
        setPreviewContent(overlayIconPreview, content);
      };

      const setReferencePreviewContent = (content) => {
        setPreviewContent(promptReferencePreview, content);
      };

      const revokeOverlayObjectUrl = () => {
        const { objectUrl } = state.customOverlay || {};
        if (objectUrl) {
          try {
            URL.revokeObjectURL(objectUrl);
          } catch (err) {
            console.warn('Failed to revoke overlay object URL', err);
          }
        }
      };

      const clearCustomOverlay = (message = DEFAULT_OVERLAY_MESSAGE) => {
        revokeOverlayObjectUrl();
        state.customOverlay = { bitmap: null, objectUrl: '', name: '' };
        setOverlayPreviewContent(message);
        if (overlayIconUpload) {
          overlayIconUpload.value = '';
        }
        state.vibePreviewActive = !state.imageBitmap;
        state.showEdgeDefault = !state.imageBitmap;
        state.needsRender = true;
      };

      const clearReferenceImage = (message = DEFAULT_REFERENCE_MESSAGE) => {
        state.referenceImage = {
          base64: '',
          mimeType: '',
          name: '',
          dataUrl: '',
          signature: '',
        };
        setReferencePreviewContent(message);
        if (promptReferenceUpload) {
          promptReferenceUpload.value = '';
        }
      };

      const handleOverlayUpload = async (file) => {
        if (!file) return;
        let nextObjectUrl = '';
        try {
          validateOverlayFile(file);
          setOverlayPreviewContent('Loading logoâ€¦');
          nextObjectUrl = URL.createObjectURL(file);
          const img = await loadImageFromSource(nextObjectUrl, file.name || 'logo');
          const bitmap = await createImageBitmapSafe(img);
          revokeOverlayObjectUrl();
          state.customOverlay = {
            bitmap,
            objectUrl: nextObjectUrl,
            name: file.name || 'Uploaded logo',
          };
          const previewImg = document.createElement('img');
          previewImg.src = state.customOverlay.objectUrl;
          previewImg.alt = file.name ? `${file.name} preview` : 'Uploaded logo preview';
          setOverlayPreviewContent(previewImg);
          if (overlayIconUpload) {
            overlayIconUpload.value = '';
          }
          state.vibePreviewActive = !state.imageBitmap;
          state.showEdgeDefault = false;
          state.needsRender = true;
          nextObjectUrl = '';
        } catch (err) {
          console.error(err);
          if (nextObjectUrl) {
            try {
              URL.revokeObjectURL(nextObjectUrl);
            } catch (revokeErr) {
              console.warn('Failed to revoke new overlay URL', revokeErr);
            }
            nextObjectUrl = '';
          }
          clearCustomOverlay(err.message || DEFAULT_OVERLAY_MESSAGE);
        }
      };

      const handleReferenceUpload = async (file) => {
        if (!file) return;
        try {
          validateFile(file);
          setReferencePreviewContent('Loading referenceâ€¦');
          const dataUrl = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(new Error('Failed to read file.'));
            reader.readAsDataURL(file);
          });
          if (typeof dataUrl !== 'string') {
            throw new Error('We could not read that image. Try again.');
          }
          const commaIndex = dataUrl.indexOf(',');
          const base64 = commaIndex >= 0 ? dataUrl.slice(commaIndex + 1) : '';
          if (!base64) {
            throw new Error('We could not process that image. Try a different file.');
          }
          const signatureSource = base64.slice(0, 32);
          const signature = signatureSource.replace(/[^a-z0-9]/gi, '').slice(0, 16) || Date.now().toString(36);
          state.referenceImage = {
            base64,
            mimeType: file.type || 'image/png',
            name: file.name || 'Reference image',
            dataUrl,
            signature,
          };
          const previewImg = document.createElement('img');
          previewImg.src = dataUrl;
          previewImg.alt = `${state.referenceImage.name} preview`;
          setReferencePreviewContent(previewImg);
          if (promptReferenceUpload) {
            promptReferenceUpload.value = '';
          }
        } catch (err) {
          console.error(err);
          clearReferenceImage(err instanceof Error ? err.message : DEFAULT_REFERENCE_MESSAGE);
        }
      };

      const CACHE_KEY_PREFIX = 'neon-case-lab:';

      const cacheDesign = (prompt, dataUrl) => {
        // Session cache prevents hitting Gemini twice for the same idea
        try {
          const payload = { timestamp: Date.now(), dataUrl };
          sessionStorage.setItem(CACHE_KEY_PREFIX + prompt.trim().toLowerCase(), JSON.stringify(payload));
        } catch (err) {
          console.warn('Cache failed', err);
        }
      };

      const getCachedDesign = (prompt) => {
        try {
          const raw = sessionStorage.getItem(CACHE_KEY_PREFIX + prompt.trim().toLowerCase());
          if (!raw) return null;
          const payload = JSON.parse(raw);
          return payload.dataUrl;
        } catch (err) {
          console.warn('Cache read failed', err);
          return null;
        }
      };

      const buildStructuredPrompt = () => {
        const sanitize = (text = '') => text.replace(/"/g, "'");
        const basePrompt = sanitize(promptInput.value.trim());
        const vibe = getActiveVibe();
        const layout = getSelectedLayout();
        const overlayText = sanitize((state.selections.overlayText || '').trim());

        const safePrompt = basePrompt || 'abstract light trails with premium polish';
        const parts = [
          `Create a premium phone case design based on the prompt: "${safePrompt}".`
        ];

        if (vibe) {
          const styleDetail = vibe.stylePrompt ? `, emphasizing ${vibe.stylePrompt}.` : '.';
          parts.push(`Style it in the "${vibe.name}" aesthetic${styleDetail}`);
        }

        if (layout?.prompt) {
          parts.push(`Use ${layout.prompt}.`);
        }

        if (overlayText) {
          parts.push(`Include the text "${overlayText}" as a polished overlay that remains legible on a phone case.`);
        }

        if (state.customOverlay?.bitmap) {
          const accentArea = layout?.label ? layout.label.toLowerCase() : 'accent area';
          parts.push(`Leave clear space near the ${accentArea} so a custom uploaded logo overlay can be layered cleanly.`);
        }

        if (state.referenceImage?.base64) {
          const referenceName = sanitize(state.referenceImage.name || 'reference image');
          const signature = state.referenceImage.signature ? ` (ref:${state.referenceImage.signature})` : '';
          parts.push(`Use the uploaded reference image '${referenceName}'${signature} as the primary subject while applying the requested scene. Preserve the subject's defining traits so the final artwork still clearly relates to the original photo.`);
        }

        parts.push('Maintain balanced composition, crisp detail, and keep the artwork printable for a phone case.');

        return parts.join(' ');
      };

      // Direct Gemini image generation call using the official REST payload with automatic retry
      const generateWithGemini = async (prompt, retryCount = 0, maxRetries = 3) => {
        const parts = [];

        if (state.referenceImage?.base64) {
          parts.push({
            inline_data: {
              mime_type: state.referenceImage.mimeType || 'image/png',
              data: state.referenceImage.base64,
            },
          });
        }

        parts.push({
          text: `${prompt}\n\nMake it suitable for printing on a phone case. Generate a vibrant, high-quality design.`
        });

        const response = await fetch(GEMINI_ENDPOINT, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            contents: [{
              parts,
            }],
            generationConfig: {
              temperature: 0.9,
              candidateCount: 1,
            }
          }),
        });
        if (!response.ok) {
          if (response.status === 429) {
            const retryAfterHeader = response.headers.get('retry-after');
            const retryAfterSeconds = retryAfterHeader ? Number(retryAfterHeader) : RATE_LIMIT_FALLBACK_MS / 1000;
            const retryMs = Number.isFinite(retryAfterSeconds) && retryAfterSeconds > 0
              ? retryAfterSeconds * 1000
              : RATE_LIMIT_FALLBACK_MS;
            
            // Auto-retry with exponential backoff
            if (retryCount < maxRetries) {
              const waitTime = Math.min(retryMs * Math.pow(1.5, retryCount), 60000); // Max 60s
              const seconds = Math.ceil(waitTime / 1000);
              rateLimitUntil = Date.now() + waitTime;
              
              setStatus(aiStatus, `Rate limited. Auto-retrying in ${seconds}s... (${retryCount + 1}/${maxRetries})`, 'error');
              
              // Countdown timer
              const countdownInterval = setInterval(() => {
                const remaining = Math.ceil((rateLimitUntil - Date.now()) / 1000);
                if (remaining > 0) {
                  setStatus(aiStatus, `Rate limited. Auto-retrying in ${remaining}s... (${retryCount + 1}/${maxRetries})`, 'error');
                } else {
                  clearInterval(countdownInterval);
                }
              }, 1000);
              
              await new Promise(resolve => setTimeout(resolve, waitTime));
              clearInterval(countdownInterval);
              
              setStatus(aiStatus, `Retrying... (attempt ${retryCount + 2}/${maxRetries + 1})`);
              return generateWithGemini(prompt, retryCount + 1, maxRetries);
            }
            
            // Max retries reached
            rateLimitUntil = Date.now() + retryMs;
            const seconds = Math.ceil(retryMs / 1000);
            throw new Error(`Rate limit reached after ${maxRetries} retries. Please wait ${seconds}s before trying again.`);
          }

          let detail = '';
          try {
            const errorPayload = await response.clone().json();
            detail = errorPayload?.error?.message || errorPayload?.message || '';
          } catch (jsonErr) {
            try {
              detail = await response.clone().text();
            } catch (textErr) {
              // ignored â€“ fall back to generic message
            }
          }
          const message = detail
            ? `${detail} (Status ${response.status})`
            : `Gemini request failed (${response.status}).`;
          throw new Error(message);
        }
        return await response.json();
      };

      const extractImageFromGemini = (payload) => {
        const candidate = payload?.candidates?.[0];
        const parts = candidate?.content?.parts || [];
        for (const part of parts) {
          if (part.inlineData?.data) {
            const mime = part.inlineData.mimeType || 'image/png';
            return `data:${mime};base64,${part.inlineData.data}`;
          }
          if (part.fileData?.fileUri) {
            return part.fileData.fileUri;
          }
        }
        throw new Error('No image returned by Gemini.');
      };

      const handleGeminiGeneration = async () => {
        const rawPrompt = promptInput.value.trim();
        if (!rawPrompt) {
          setStatus(aiStatus, 'Add a prompt first.');
          return;
        }
        const finalPrompt = buildStructuredPrompt();
        const cached = getCachedDesign(finalPrompt);
        if (cached) {
          setStatus(aiStatus, 'Loaded from session cache.');
          const img = await loadImageFromSource(cached, 'cached design');
          await applyImage(img, { focusPreview: true });
          return;
        }

        const now = Date.now();
        if (now < rateLimitUntil) {
          const seconds = Math.ceil((rateLimitUntil - now) / 1000);
          setStatus(aiStatus, `Gemini is cooling down. Try again in ${seconds}s.`, 'error');
          return;
        }

        try {
          setLoading(true);
          setStatus(aiStatus, 'Contacting Geminiâ€¦');
          const payload = await generateWithGemini(finalPrompt);
          const dataUrl = extractImageFromGemini(payload);
          const img = await loadImageFromSource(dataUrl, 'Gemini design');
          await applyImage(img, { focusPreview: true });
          rateLimitUntil = 0;
          cacheDesign(finalPrompt, dataUrl);
          setStatus(aiStatus, 'âœ¨ Design created successfully! Use sliders to customize.', 'success');
          setTimeout(() => setStatus(aiStatus, ''), 4000);
        } catch (err) {
          console.error(err);
          setStatus(aiStatus, err.message || 'Gemini generation failed.', 'error');
        } finally {
          setLoading(false);
        }
      };

      const debouncedGemini = debounce(handleGeminiGeneration, 500);

      const pointerPos = (event) => {
        const rect = canvas.getBoundingClientRect();
        return {
          x: ((event.clientX - rect.left) / rect.width) * canvas.width,
          y: ((event.clientY - rect.top) / rect.height) * canvas.height,
        };
      };

      const onPointerDown = (event) => {
        if (!state.imageBitmap) return;
        state.dragging = true;
        canvas.setPointerCapture(event.pointerId);
        const pos = pointerPos(event);
        state.dragStart = pos;
        state.initialPos = { x: state.transform.x, y: state.transform.y };
        canvasWrapper.classList.add('dragging');
      };

      const onPointerMove = (event) => {
        if (!state.dragging) return;
        const pos = pointerPos(event);
        const dx = pos.x - state.dragStart.x;
        const dy = pos.y - state.dragStart.y;
        state.transform.x = state.initialPos.x + dx;
        state.transform.y = state.initialPos.y + dy;
        state.needsRender = true;
      };

      const onPointerUp = (event) => {
        if (!state.dragging) return;
        state.dragging = false;
        canvas.releasePointerCapture(event.pointerId);
        canvasWrapper.classList.remove('dragging');
        state.needsRender = true;
      };

      const update3DTexture = () => {
        if (!state.three.enabled || !state.three.texture) return;
        state.three.texture.needsUpdate = true;
      };

      // Lazy-load Three.js only when the user opts into the 3D orbit preview
      const init3DPreview = async () => {
        if (!has3DPreviewSection || !toggle3d) {
          if (toggle3d) toggle3d.checked = false;
          return;
        }
        if (state.three.enabled) return;
        preview3dPlaceholder.textContent = 'Loading 3D previewâ€¦';
        try {
          await loadThreeCore();
          await loadOrbitControls();
        } catch (err) {
          console.error(err);
          preview3dPlaceholder.textContent = 'Three.js failed to load.';
          toggle3d.checked = false;
          return;
        }

        const THREE = window.THREE;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a13);
        const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
        camera.position.set(0, 0, 3.5);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const size = preview3dContainer.clientWidth;
        renderer.setSize(size, size, false);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        preview3dContainer.innerHTML = '';
        preview3dContainer.appendChild(renderer.domElement);

        const light = new THREE.HemisphereLight(0xffffff, 0x080820, 1.2);
        scene.add(light);
        const directional = new THREE.DirectionalLight(0xffffff, 0.6);
        directional.position.set(2, 2, 3);
        scene.add(directional);

        const phoneGeometry = new THREE.BoxGeometry(1.9, 4, 0.18, 20, 20, 4);
        const texture = new THREE.CanvasTexture(canvas);
        texture.flipY = false;
        texture.anisotropy = 8;
        const materialFront = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.6, metalness: 0.1 });
        const materialBody = new THREE.MeshStandardMaterial({ color: 0x11131f, roughness: 0.8, metalness: 0.2 });
        const materials = [materialBody, materialBody, materialBody, materialBody, materialFront, materialBody];
        const mesh = new THREE.Mesh(phoneGeometry, materials);
        scene.add(mesh);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.minDistance = 2.5;
        controls.maxDistance = 6;
        controls.enablePan = false;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.2;

        const handleResize = () => {
          const newSize = preview3dContainer.clientWidth;
          renderer.setSize(newSize, newSize, false);
          camera.aspect = 1;
          camera.updateProjectionMatrix();
        };

        window.addEventListener('resize', handleResize);

        let rafId = 0;
        const animate = () => {
          controls.update();
          renderer.render(scene, camera);
          texture.needsUpdate = true;
          rafId = requestAnimationFrame(animate);
          if (state.three.enabled) {
            state.three.raf = rafId;
          }
        };
        animate();

        state.three = {
          enabled: true,
          scene,
          renderer,
          camera,
          controls,
          mesh,
          texture,
          raf: rafId,
          cleanup: () => {
            cancelAnimationFrame(rafId);
            window.removeEventListener('resize', handleResize);
            renderer.dispose();
            texture.dispose();
            phoneGeometry.dispose();
          },
        };
      };

      const destroy3DPreview = () => {
        if (!state.three.enabled) return;
        state.three.cleanup?.();
        state.three = {
          enabled: false,
          scene: null,
          renderer: null,
          camera: null,
          controls: null,
          mesh: null,
          texture: null,
          raf: 0,
        };
        if (preview3dContainer && preview3dPlaceholder) {
          preview3dContainer.innerHTML = '';
          preview3dContainer.appendChild(preview3dPlaceholder);
        }
      };

      const loadThreeCore = () => new Promise((resolve, reject) => {
        if (window.THREE) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load three.min.js'));
        document.head.appendChild(script);
      });

      const loadOrbitControls = () => new Promise((resolve, reject) => {
        if (window.THREE?.OrbitControls) {
          resolve();
          return;
        }
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/js/controls/OrbitControls.js';
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load OrbitControls'));
        document.head.appendChild(script);
      });

      // Upscale render (~300 DPI) and export the masked design as a PNG
      const performExport = async () => {
        if (!state.imageBitmap && !state.customOverlay?.bitmap) {
          setStatus(exportStatus, 'Add or generate a design first.', 'error');
          return;
        }
        setStatus(exportStatus, 'Preparing high-resolution exportâ€¦');
        try {
          const EXPORT_SCALE = 300 / 96;
          const exportCanvas = document.createElement('canvas');
          exportCanvas.width = Math.round(caseWidth * EXPORT_SCALE);
          exportCanvas.height = Math.round(caseHeight * EXPORT_SCALE);
          const eCtx = exportCanvas.getContext('2d');
          eCtx.scale(EXPORT_SCALE, EXPORT_SCALE);
          eCtx.clearRect(0, 0, caseWidth, caseHeight);
          eCtx.save();
          clipToPhoneMask(eCtx);
          if (state.imageBitmap) {
            eCtx.save();
            eCtx.translate(state.transform.x, state.transform.y);
            eCtx.rotate((state.transform.rotation * Math.PI) / 180);
            const scale = state.baseScale * state.transform.scale;
            eCtx.scale(scale, scale);
            eCtx.globalAlpha = state.transform.opacity;
            eCtx.drawImage(state.imageBitmap, -state.imageBitmap.width / 2, -state.imageBitmap.height / 2);
            eCtx.restore();
          }
          if (state.customOverlay?.bitmap) {
            drawCustomOverlay(eCtx);
          }
          eCtx.restore();
          eCtx.drawImage(caseLightingOverlay, 0, 0);
          const link = document.createElement('a');
          link.download = 'neon-case-design.png';
          link.href = exportCanvas.toDataURL('image/png');
          link.click();
          setStatus(exportStatus, 'PNG downloaded at ~300 DPI.');
        } catch (err) {
          console.error(err);
          setStatus(exportStatus, 'Export failed. Try again.', 'error');
        }
      };

      generateBtn.addEventListener('click', () => debouncedGemini());
      promptInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' && (event.metaKey || event.ctrlKey)) {
          debouncedGemini();
        }
      });

      quickPromptButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const preset = btn.dataset.prompt;
          promptInput.value = preset || '';
          setStatus(aiStatus, 'Prompt loaded. Adjust the details and generate when ready.');
          if (!state.imageBitmap) {
            state.vibePreviewActive = true;
            state.showEdgeDefault = false;
            state.needsRender = true;
          }
          promptInput.focus();
        });
      });

      const applyLayoutSelection = (layoutId, options = {}) => {
        const { activatePreview = true } = options;
        state.selections.layout = layoutId;
        layoutRadios.forEach((radio) => {
          radio.checked = radio.value === layoutId;
        });
        if (!state.imageBitmap) {
          if (activatePreview) {
            state.vibePreviewActive = true;
            state.showEdgeDefault = false;
          }
          state.needsRender = true;
        }
      };

      layoutRadios.forEach((radio) => {
        radio.addEventListener('change', () => {
          if (radio.checked) {
            applyLayoutSelection(radio.value);
          }
        });
      });

      applyLayoutSelection(state.selections.layout, { activatePreview: false });

      if (overlayTextInput) {
        overlayTextInput.addEventListener('input', () => {
          state.selections.overlayText = overlayTextInput.value;
          if (!state.imageBitmap) {
            state.vibePreviewActive = true;
            state.showEdgeDefault = false;
            state.needsRender = true;
          }
        });
      }

      if (overlayIconUpload) {
        overlayIconUpload.addEventListener('change', (event) => {
          const file = event.target?.files?.[0];
          handleOverlayUpload(file);
        });
      }

      if (overlayIconClear) {
        overlayIconClear.addEventListener('click', () => {
          clearCustomOverlay();
        });
      }

      if (overlayIconPreview) {
        setOverlayPreviewContent(DEFAULT_OVERLAY_MESSAGE);
      }

      if (promptReferenceUpload) {
        promptReferenceUpload.addEventListener('change', (event) => {
          const file = event.target?.files?.[0];
          handleReferenceUpload(file);
        });
      }

      if (promptReferenceClear) {
        promptReferenceClear.addEventListener('click', () => {
          clearReferenceImage();
        });
      }

      if (promptReferencePreview) {
        setReferencePreviewContent(DEFAULT_REFERENCE_MESSAGE);
      }

      if (vibeDots) {
        vibeDots.innerHTML = '';
        VIBE_CATEGORIES.forEach((vibe, index) => {
          const dot = document.createElement('button');
          dot.type = 'button';
          dot.className = 'vibe-dot';
          dot.setAttribute('aria-label', `${vibe.name} vibe`);
          dot.setAttribute('aria-pressed', index === state.selections.vibeIndex ? 'true' : 'false');
          dot.addEventListener('click', () => setVibeIndex(index));
          vibeDots.append(dot);
          vibeDotsButtons.push(dot);
        });
      }

      if (vibePrevBtn) {
        vibePrevBtn.addEventListener('click', () => cycleVibe(-1));
      }

      if (vibeNextBtn) {
        vibeNextBtn.addEventListener('click', () => cycleVibe(1));
      }

      const handleSurprise = () => {
        const preset = randomFrom(SURPRISE_PRESETS);
        if (!preset) return;
        promptInput.value = preset.prompt;
        setStatus(aiStatus, 'Shuffling a fresh concept for you...');
        const vibeIndex = VIBE_CATEGORIES.findIndex((vibe) => vibe.id === preset.vibeId);
        if (vibeIndex >= 0) {
          setVibeIndex(vibeIndex);
        }
        if (preset.layout) {
          applyLayoutSelection(preset.layout);
        }
        if (overlayTextInput) {
          overlayTextInput.value = preset.overlayText || '';
        }
        state.selections.overlayText = preset.overlayText || '';
        state.vibePreviewActive = true;
        state.showEdgeDefault = false;
        state.needsRender = true;
        handleGeminiGeneration();
      };

      if (surpriseBtn) {
        surpriseBtn.addEventListener('click', handleSurprise);
      }

      setVibeIndex(state.selections.vibeIndex, { activatePreview: false });

      dropZone.addEventListener('click', () => fileInput.click());
      dropZone.addEventListener('keydown', (event) => {
        if (event.key === 'Enter' || event.key === ' ') {
          event.preventDefault();
          fileInput.click();
        }
      });

      dropZone.addEventListener('dragover', (event) => {
        event.preventDefault();
        dropZone.classList.add('dragover');
      });

      dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
      });

      dropZone.addEventListener('drop', (event) => {
        event.preventDefault();
        dropZone.classList.remove('dragover');
        const file = event.dataTransfer.files?.[0];
        if (file) handleFile(file);
      });

      fileInput.addEventListener('change', () => {
        const file = fileInput.files?.[0];
        if (file) handleFile(file);
      });

      scaleSlider.addEventListener('input', () => {
        state.transform.scale = parseFloat(scaleSlider.value);
        state.needsRender = true;
        updateTransformInfo();
      });

      rotationSlider.addEventListener('input', () => {
        state.transform.rotation = parseFloat(rotationSlider.value);
        state.needsRender = true;
        updateTransformInfo();
      });

      opacitySlider.addEventListener('input', () => {
        state.transform.opacity = parseFloat(opacitySlider.value);
        state.needsRender = true;
        updateTransformInfo();
      });

      previewBtn.addEventListener('click', () => {
        state.showMask = !state.showMask;
        canvasWrapper.classList.toggle('preview-mask', state.showMask);
        previewBtn.textContent = state.showMask ? 'Hide Mask Preview' : 'Preview Mask';
      });

      downloadBtn.addEventListener('click', performExport);

      if (toggle3d) {
        toggle3d.addEventListener('change', () => {
          if (!has3DPreviewSection) {
            toggle3d.checked = false;
            return;
          }
          if (toggle3d.checked) {
            init3DPreview();
          } else {
            destroy3DPreview();
          }
        });
      }

      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      canvas.addEventListener('pointerup', onPointerUp);
      canvas.addEventListener('pointerleave', onPointerUp);
      canvas.addEventListener('pointercancel', onPointerUp);

      // Keyboard shortcuts
      document.addEventListener('keydown', (event) => {
        // Cmd/Ctrl + Enter to generate
        if ((event.metaKey || event.ctrlKey) && event.key === 'Enter') {
          event.preventDefault();
          if (!generateBtn.disabled && promptInput.value.trim()) {
            handleGeminiGeneration();
          }
        }
        // Escape to clear status messages
        if (event.key === 'Escape') {
          if (aiStatus.textContent) setStatus(aiStatus, '');
          if (uploadStatus.textContent) setStatus(uploadStatus, '');
          if (exportStatus.textContent) setStatus(exportStatus, '');
        }
      });

      // Phone model switcher with image update
      const initPhoneModelSwitcher = () => {
        const phoneSelect = document.getElementById('phoneModel');
        
        if (!phoneSelect) {
          console.error('Phone select element not found!');
          return;
        }
        
        console.log('Initializing phone model switcher');
        console.log('Available models:', Object.keys(phoneModels));
        
        // Function to update phone model
        const updatePhoneModel = (modelKey) => {
          const model = phoneModels[modelKey];
          if (!model || !model.image) {
            console.error('Model not found or no image:', modelKey);
            return;
          }
          
          console.log('Updating to:', model.name, 'Width:', model.width, 'Height:', model.height);
          
          // Get wrapper and remove ALL existing phoneImage elements
          const wrapper = document.getElementById('canvasWrapper');
          if (!wrapper) return;
          
          // Remove ALL existing phoneImage elements
          const existingImages = wrapper.querySelectorAll('img#phoneImage');
          existingImages.forEach(img => img.remove());
          
          // Create ONE new phoneImage element
          const newImg = document.createElement('img');
          newImg.id = 'phoneImage';
          newImg.src = model.image;
          newImg.alt = `${model.name} case`;
          newImg.width = model.width;
          newImg.height = model.height;
          newImg.style.width = model.width + 'px';
          newImg.style.height = model.height + 'px';
          newImg.style.position = 'absolute';
          newImg.style.top = '50%';
          newImg.style.left = '50%';
          newImg.style.transform = 'translate(-50%, -50%)';
          newImg.style.zIndex = '1';
          newImg.style.pointerEvents = 'none';
          newImg.style.filter = 'drop-shadow(0 20px 40px rgba(0, 0, 0, 0.4))';
          newImg.style.opacity = '1';
          newImg.style.mixBlendMode = 'normal';
          newImg.style.objectFit = 'contain';
          newImg.style.transition = 'opacity 200ms ease';
          // Insert before the canvas so canvas is always above
          wrapper.insertBefore(newImg, wrapper.querySelector('canvas'));

          // Update canvas dimensions
          canvas.width = model.width;
          canvas.height = model.height;

          // Update wrapper height to match aspect ratio
          const aspectRatio = model.height / model.width;
          const newHeight = Math.min(420, window.innerWidth * 0.92) * aspectRatio;
          wrapper.style.minHeight = `${newHeight}px`;

          // Regenerate phone mask for new dimensions and camera layout
          phoneMask = createPhoneMask(model.width, model.height, cornerRadius, model.cameraLayout);

          // Regenerate lighting overlay for new dimensions
          caseLightingOverlay = createCaseLightingOverlay(model.width, model.height, phoneMask);

          // Recalculate base scale for new dimensions
          if (state.image) {
            const coverScale = Math.max(model.width / state.image.width, model.height / state.image.height);
            state.baseScale = coverScale;
            state.transform.x = model.width / 2;
            state.transform.y = model.height / 2;
          }

          state.needsRender = true;
          setStatus(exportStatus, `âœ“ Switched to ${model.name}`, 'success');
          setTimeout(() => setStatus(exportStatus, ''), 2000);
        };
        
        // Add change listener
        phoneSelect.addEventListener('change', (e) => {
          console.log('Phone model changed to:', e.target.value);
          updatePhoneModel(e.target.value);
        });
        
        // Set initial phone image
        updatePhoneModel(phoneSelect.value || 'iphone15');
      };
      
      // Initialize after a short delay to ensure DOM is ready
      setTimeout(initPhoneModelSwitcher, 100);

      ensureEdgeLogoImage();
      renderLoop();
      updateTransformInfo();
    })();
  </script>
</body>
</html>
